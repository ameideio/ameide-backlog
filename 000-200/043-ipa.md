> **DEPRECATED**: This document describes the legacy IPA (Intelligent Process
> Automation) architecture. The concepts here have been superseded by:
> - **[471â€‘ameideâ€‘businessâ€‘architecture](../471-ameide-business-architecture.md)**:
>   DomainService, ProcessController, AgentRuntime, UIWorkspace model
> - **[475â€‘ameideâ€‘domains](../475-ameide-domains.md)**: Domain portfolio and patterns
> - **[470â€‘ameideâ€‘vision](../470-ameide-vision.md)**: Platform vision and principles
>
> **Do not use "IPA" in customerâ€‘facing communications.** Use "domains, processes,
> agents, and workspaces" terminology instead.

# 043 â€“ IPA Architecture: Core Domain Model to Runtime Deployment

Status: **COMPLETED** (Phases 1-3, Phase 4 Designer pending)  
Author: platform-architecture  
Created: 2025-01-26
Updated: 2025-01-26 (Phase 1, 2 & 3 completed, file-based approach removed, all tests passing)

## Problem statement

The platform needs a unified way to compose workflows, agents, and tools into cohesive automations. Currently:
- No formal model for composing these elements together
- Each component type managed separately
- No clear path from design to deployment
- Runtime concerns mixed with domain logic

## Actual Use Case

Ameide provides a low-code platform where:
1. Users design automations via UI (not files)
2. Platform stores designs in PostgreSQL (not git)
3. Background compiler generates runtime code
4. Hot-deployed endpoints serve the automation

This is fundamentally different from a file-based package system.

## Proposed Architecture

### Layered Approach

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   UI Designer   â”‚  (Visual composition of automations)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Core Domain    â”‚  (IPA as first-class domain model)
â”‚  - IPADomain    â”‚
â”‚  - Workflows    â”‚
â”‚  - Agents       â”‚
â”‚  - Tools        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Core Storage   â”‚  (PostgreSQL persistence)
â”‚  - Versioning   â”‚
â”‚  - Multi-tenant â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  IPA Builder    â”‚  (Orchestrates component builders)
â”‚  - Validates    â”‚
â”‚  - Compiles     â”‚
â”‚  - Deploys      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Runtimes     â”‚  (Temporal, LangGraph, etc.)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Implementation Status

- **Phase 1: Core Domain Model** âœ… COMPLETED
- **Phase 2: Persistence Layer** âœ… COMPLETED  
- **Phase 3: Builder Enhancement** âœ… COMPLETED (All tests passing)
- **Phase 4: Designer Layer** ðŸ”„ TODO (Future work)

## Implementation Plan

### Phase 1: Core Domain Model âœ… COMPLETED

#### 1. Add IPA to core-domain
```python
# packages/ameide_core-domain/src/ameide_core_domain/ipa/models.py
class IPADomain(BaseModel):
    """Core domain model for IPA composition."""
    id: str
    name: str
    version: str
    tenant_id: str
    
    # Composition (enhanced to support mixed deployments)
    workflows_refs: List[ComponentReference]
    agent_refs: List[ComponentReference] 
    tool_refs: List[ComponentReference]
    
    # Entry point can be workflows OR agent
    entry_component_id: str
    entry_component_type: str  # "workflows" or "agent"
    
    # Deployment strategies for mixed runtimes
    deployment_strategies: List[IPADeploymentStrategy]
    
    # Configuration
    state_schema: Dict[str, Any]
    shared_memory_config: Dict[str, Any]
```

**Key Implementation Details:**
- Components can be deployed to different runtimes (workflows â†’ Temporal, agents â†’ LangGraph)
- Entry point supports both workflows and agents
- Deployment strategies capture per-component runtime targets
- Full test coverage with mixed deployment scenarios

#### 2. Harmonize Existing Models
- Keep `core-workflows-model` for BPMN representation
- Keep `core-agent-model` for agent graphs
- Keep `core-tool-model` for tool definitions
- Update `core-ipa-model` to focus on composition

### Phase 2: Persistence Layer âœ… COMPLETED

#### 1. Extend core-storage
```python
# packages/ameide_core-storage/src/ameide_core_storage/sql/ipa_graph.py
class IPARepository(Repository[IPAEntity]):
    async def save_ipa(self, ipa: IPADomain) -> IPADomain
    async def find_by_tenant(self, tenant_id: str) -> List[IPADomain]
    async def get_deployment_status(self, ipa_id: str) -> DeploymentStatus
```

**Key Implementation Details:**
- Full CRUD operations for IPA domain models
- Version tracking with auto-increment
- Multi-tenant isolation
- Support for mixed runtime deployments
- Separate graph for IPA executions
- Full-text search capability
- JSONB storage for flexible schemas

#### 2. Database Schema
```sql
CREATE TABLE ipa_designs (
    id UUID PRIMARY KEY,
    version INTEGER NOT NULL,
    design_data JSONB NOT NULL,
    tenant_id UUID NOT NULL,
    created_at TIMESTAMPTZ NOT NULL,
    UNIQUE(id, version)
);
```

### Phase 3: Builder Enhancement âœ… COMPLETED

#### 1. Update core-ipa-builder
```python
# packages/ameide_core-ipa-builder/src/ameide_core_ipa_builder/builder.py
class IPABuilder:
    """Main builder for Intelligent Process Automations from database."""
    
    def __init__(self, config: IPABuildConfig, ipa_graph: IPARepository):
        """Initialize builder with configuration and graph."""
        self.config = config
        self.ipa_graph = ipa_graph
        self.domain_builder = IPADomainBuilder(config, ipa_graph)
```

**Key Implementation Details:**
- Removed all file-based approaches
- Now loads IPAs exclusively from database
- Supports mixed runtime deployments
- Generates artifacts for Temporal, LangGraph, Airflow, Docker, and Kubernetes
- Full validation of generated artifacts

### Phase 4: Designer Layer ðŸ”„ TODO

#### 1. Create core-ipa-designer
```python
# packages/ameide_core-ipa-designer/src/ameide_core_ipa_designer/models.py
class IPADesignSession(BaseModel):
    """UI state for designing IPAs."""
    ipa_id: str
    canvas_state: CanvasState
    unsaved_changes: Dict[str, Any]
    validation_errors: List[str]
```

## Benefits of This Approach

### 1. Clean Architecture
- **Domain models** stay pure and framework-free
- **Storage layer** handles all persistence concerns
- **Builder** orchestrates without duplicating logic
- **Designer** isolates UI-specific concerns

### 2. Reusability
- Existing component models remain unchanged
- Builders continue to work independently
- Storage patterns consistent across all entities

### 3. Flexibility
- Can target multiple runtimes from same IPA
- Hot reload without service restart
- Version control built into database layer

### 4. Scalability
- Compiler can run as separate service
- Database handles concurrent designers
- Runtime pools can scale independently

## Key Differences from Original Proposal

### What We're NOT Doing
1. **No file-based packages** - Everything in database
2. **No OCI artifacts** - Direct deployment to runtimes  
3. **No separate ARP protocol** - Each runtime has its own
4. **No static manifests** - Dynamic generation from DB

### What We ARE Doing
1. **IPA as core domain model** - First-class business entity
2. **Database-driven** - PostgreSQL with JSONB for flexibility
3. **Hot compilation** - Background process watches for changes with debounce/rate limiting
4. **Multi-runtime support** - Same IPA can deploy to different targets

## Example Flow

```
1. User designs in UI
   â†“
2. Save IPADomain to core-domain
   â†“
3. IPARepository persists to PostgreSQL
   â†“
4. Change event triggers IPA Builder
   â†“
5. Builder orchestrates component builders
   â†“
6. Deploy to runtime (Temporal/LangGraph)
   â†“
7. REST endpoint available immediately
```

## Migration from Current State

### Current State Analysis
- ~~`core-ipa-model` exists but focuses on file-based packages~~ âœ… TO BE REMOVED
- ~~`core-ipa-builder` exists but assumes file inputs~~ âœ… REFACTORED - now database-only
- ~~No IPA in `core-domain`~~ âœ… COMPLETED
- ~~No IPA persistence in `core-storage`~~ âœ… COMPLETED

### Migration Steps
1. ~~Add IPADomain to core-domain (new file)~~ âœ… COMPLETED
2. ~~Add IPARepository to core-storage (new file)~~ âœ… COMPLETED
3. ~~Refactor core-ipa-model to remove file assumptions~~ âœ… REMOVED - file-based approach eliminated
4. ~~Update core-ipa-builder to accept domain objects~~ âœ… COMPLETED - now database-only
5. Create core-ipa-designer for UI state management ðŸ”„ TODO

## Acceptance Criteria

### Phase 1: Domain Model
- [x] IPADomain class in core-domain compiles
- [x] Unit tests pass for IPA composition logic
- [x] Support for mixed runtime deployments
- [x] Agent or workflows as entry point
- [ ] Domain events defined for IPA lifecycle

## Architectural Review Findings (2025-07-26)

### Key Concerns Identified

1. **Cross-runtime correlation** â€“ No data-sharing or compensation design for mixed runtime deployments
   - Risk: "Islands of state" between Temporal and LangGraph
   - Action: Define correlation ID propagation and shared state strategy

2. **Domain events missing** â€“ Yet later backlogs rely on a streaming feed
   - Impact: Blocks streaming APIs, SDK live updates, portal UX
   - Action: Define EventBus interface and domain event contracts immediately

3. **Builder God-object** â€“ Central `IPABuilder` already orchestrates five runtimes
   - Risk: Monolithic design, hard to extend
   - Action: Introduce plug-in registry pattern with `BuilderStrategy` interface

4. **Duplicate versioning** â€“ Field vs DB column; eventually leads to drift
   - Current: Both version field in model and DB column
   - Action: Single source of truth, use DB column only

5. **Tenant isolation** â€“ Component references omit `tenant_id`, violating multi-tenant guarantee
   - Security risk: Cross-tenant data access possible
   - Action: Add tenant_id to all ComponentReference instances

### Immediate Actions (P0/P1)

- [ ] Add domain event specification & `EventBus` interface (Day 0-3)
- [ ] Implement tenant-aware ID wrappers (AIP-122 style resource names)
- [ ] Introduce `BuilderStrategy` plug-in registry pattern (Week 2)
- [ ] Define cross-runtime correlation and state sharing mechanism
- [ ] Add missing transaction boundaries with UnitOfWork pattern

### Phase 2: Persistence  
- [x] IPARepository saves and retrieves IPAs
- [x] Version history maintained correctly
- [x] Multi-tenant isolation verified
- [x] Mixed runtime deployment persistence
- [x] SQL migration script created

### Phase 3: Builder Integration âœ… COMPLETED
- [x] IPA Builder loads from database only
- [x] Generates deployment artifacts for all runtimes
- [x] Removed all file-based approaches
- [x] CLI supports database operations
- [x] Integration tests for database operations (âœ… passing)
- [x] Integration tests for builder with mixed runtimes (âœ… passing)
- [x] End-to-end lifecycle test (design â†’ save â†’ build â†’ deploy â†’ execute) (âœ… passing)
- [x] All tests passing with proper async fixtures

### Phase 4: End-to-End
- [ ] Create IPA via API
- [ ] Background compilation triggered
- [ ] Runtime endpoint accessible
- [ ] Hot reload on changes

## Test Coverage

### Integration Tests Created
1. **test_ipa_database_integration.py**
   - CRUD operations with version tracking
   - Complex IPA persistence with mixed runtimes
   - Multi-tenant isolation
   - Search and filtering capabilities
   - Execution tracking

2. **test_ipa_builder_integration.py**
   - Simple and complex IPA builds
   - Mixed runtime artifact generation (Temporal + LangGraph + Airflow)
   - Multi-tenant build isolation
   - Draft IPA validation
   - Incremental builds with caching

3. **test_ipa_lifecycle.py**
   - Complete E2E lifecycle simulation
   - Concurrent execution handling
   - Monitoring and querying capabilities

All tests are passing with proper async fixtures and database isolation.

## References

* Original file-based proposal (deprecated)
* Executive review highlighting low-code use case
* Existing core-* packages to integrate with