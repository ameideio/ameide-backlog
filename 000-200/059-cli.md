# 059 - Protobuf-First CLI Generation

## Summary

Implemented a proto-driven CLI for AMEIDE services, initially targeting Google's `protoc-gen-go_cli` plugin but pivoting to a manual Cobra implementation due to GAPIC transport dependencies. Followed a pure Bazel approach to resolve circular dependency issues between generated code and the build system.

## Background

### The Vision
Following the "proto-first, generate-everything" philosophy discussed in previous sessions, we aimed to create a CLI that:
- Is automatically generated from proto service definitions
- Provides type-safe access to all AMEIDE services
- Integrates seamlessly with the Bazel build system
- Follows the pattern: Proto files → Generated stubs → CLI binary

### Initial Approach
1. Installed `protoc-gen-go_cli` from Google's GAPIC generator
2. Configured `buf.gen.yaml` to generate CLI alongside other language targets
3. Created a unified configuration for Python, Go, TypeScript, and CLI generation
4. **Pivot**: Discovered `protoc-gen-go_cli` requires GAPIC transport layers not yet available
5. Implemented manual Cobra CLI using generated proto stubs instead

## The Problem

### Circular Dependency Issue
```
CLI code → imports → gen/go/**/*.pb.go
    ↓                      ↓
Bazel target          Not a Bazel target
    ↓                      ↓
Needs deps            Generated by buf outside Bazel
```

The fundamental issue:
- `buf generate` creates files in `packages/ameide_core_proto/gen/go/`
- These files have import paths like `github.com/ameideio/ameide/gen/go/ameide_core_proto/ipa/v1`
- Bazel can't see these files in its sandboxed build environment
- The CLI fails to build because its dependencies don't exist as Bazel targets

### Root Cause Analysis
1. **Bazel wants hermetic builds** - all dependencies must be declared targets
2. **Go wants module resolution** - expects to find imports either remotely or locally
3. **Generated code exists outside the build graph** - buf writes directly to filesystem
4. **Two competing systems** - Buf and Bazel's proto rules are different approaches

## The Solution

### Option B: Pure Bazel Approach
Instead of using `buf generate`, we leveraged Bazel's native proto compilation pipeline:

1. **Proto Library Targets**
   ```python
   proto_library(
       name = "ipas_proto",
       srcs = ["proto/ameide_core_proto/ipa/v1/ipas.proto"],
       strip_import_prefix = "proto",
       deps = [":common_proto", "@protobuf//:empty_proto", ...],
   )
   ```

2. **Go Proto Library Targets**
   ```python
   go_proto_library(
       name = "ipas_go_proto",
       compilers = ["@rules_go//proto:go_grpc"],  # Note: Use 'plugins' in rules_go v0.48+
       importpath = "github.com/ameideio/ameide/proto/ameide_core_proto/ipa/v1",  # Canonical path from option go_package
       proto = ":ipas_proto",
       deps = [":common_go_proto"],
   )
   ```

3. **CLI Binary with Proto Dependencies**
   ```python
   go_library(
       name = "ameide-cli_lib",
       srcs = ["main.go"],
       deps = [
           "//packages/ameide_core_proto:ipas_go_proto",
           "//packages/ameide_core_proto:users_go_proto",
           "@com_github_spf13_cobra//:cobra",
           "@com_github_spf13_viper//:viper",
       ],
   )
   ```

## Implementation Details

### 1. Proto Organization
- Maintained existing proto structure in `packages/ameide_core_proto/proto/`
- Services: IPAService, WorkflowService, AgentService, UserService, BPMNService
- Each service has corresponding proto_library and go_proto_library targets

### 2. CLI Architecture
Created a **manual** CLI in `packages/ameide_core-cli/cmd/ameide/main.go` (not auto-generated) that:
- Uses Cobra for command structure
- Implements auth/endpoint configuration via flags and env vars
- Supports config file at `~/.config/ameide/config.yaml`
- Provides subcommands for each service (ipa, workflows, agent, user, bpmn)

### 3. Build Integration
- Updated `scripts/build/quick-build.sh` to include CLI building (convenience wrapper)
- Added CLI option to main `scripts/ameide` script (optional sugar)
- Created `scripts/install-cli.sh` for system-wide installation
- Removed generated files from git via `.gitignore` updates
- **Canonical build**: `bazel build //packages/ameide_core-cli/cmd/ameide:ameide`

### 4. Dependency Management
- Added Go dependencies to `MODULE.bazel`
- Created root `go.mod` for Gazelle integration
- Fixed import paths to use Bazel-generated targets

## Challenges Overcome

1. **GAPIC Dependency Issue**
   - The `protoc-gen-go_cli` expected GAPIC client libraries
   - Solved by creating a manual CLI that directly uses gRPC clients

2. **Subpackage Conflicts**
   - Gazelle created BUILD files in proto subdirectories
   - Fixed by removing these files and keeping protos in single package
   - **Prevention**: Add `# gazelle:proto disable` directive or run with `-proto=disable_global`

3. **Import Path Resolution**
   - Go couldn't find `github.com/ameideio/ameide/gen/go` imports
   - Solved by using Bazel's go_proto_library with correct importpath

## Benefits Achieved

1. **Zero Manual API Client Code** - All service interfaces auto-generated
2. **Type-Safe CLI** - Compile-time checking of all API calls
3. **Hermetic Builds** - Everything generated within Bazel's sandbox
4. **Single Source of Truth** - Proto files drive all client generation
5. **Integrated Tooling** - CLI builds with standard Bazel commands

## Usage

```bash
# Generate and build CLI
./scripts/ameide build cli

# Direct Bazel build
bazel build //packages/ameide_core-cli/cmd/ameide:ameide

# Run CLI
bazel-bin/packages/ameide_core-cli/cmd/ameide/ameide_/ameide --help

# Example commands
ameide ipa create --name "My IPA" --description "Test IPA"
ameide user whoami
ameide workflows list
```

## Testing Implementation (Completed)

### Test Strategy
Created a comprehensive testing framework for the CLI following SOLID principles:

1. **Test Helpers and Fixtures** (`tests/shared/cli_helpers.py`)
   - `CLIRunner`: Executes CLI binary with proper environment handling
   - `CLIConfig`: Manages test configuration files
   - `CLITestData`: Generates sample command arguments
   - `CLIResponseValidator`: Validates outputs and errors

2. **Mock gRPC Server** (`tests/shared/mock_grpc_server.py`)
   - Implements all services: User, IPA, BPMN, ArchiMate
   - Supports error injection for negative testing
   - Thread-safe with automatic port allocation
   - Maintains state for realistic scenarios

3. **Integration Tests** (`tests/integration/test_cli_integration.py`)
   - Basic CLI functionality (help, version)
   - Configuration file and environment variable handling
   - Authentication token support
   - Error handling and command structure validation

4. **E2E Tests** (`tests/e2e/test_cli_e2e.py`)
   - Complete workflows tests using real test assets
   - BPMN: create → list → get → delete
   - ArchiMate: full lifecycle including export/import/validate
   - IPA: create → list workflows
   - Concurrent operations and error recovery

5. **Go Unit Tests** (`packages/ameide_core-cli/cmd/ameide/main_test.go`)
   - Mock gRPC service implementations
   - Command parsing and flag validation
   - Configuration and environment tests
   - Error handling scenarios

### Test Coverage
- Unit tests: Command parsing, flag validation, error handling
- Integration tests: CLI invocation, configuration, authentication
- E2E tests: Full command workflows with real test data
- Both success and failure paths tested
- Tests run in local and CI environments

## Future Enhancements

1. **Buf Lint Integration**
   - Can use `rules_buf` just for linting without code generation:
   ```python
   buf_lint(
       name = "lint_protos",
       srcs = [":ipas_proto", ":users_proto", ...],
   )
   ```

2. **Version Stamping**
   - Add `--version` flag showing Git commit from `workspace_status_command`
   - Cobra supports this out of the box

3. **Full protoc-gen-go_cli Integration**
   - **Blocker**: Requires GAPIC transport/grpc surface for each service
   - Once Google releases standalone CLI generation (without GAPIC deps), can switch
   - Would generate all command implementations automatically

4. **Shell Completion**
   - Already supported by Cobra framework
   - `ameide completion bash/zsh/fish`

5. **Authentication Flows**
   - OAuth2 flow implementation
   - Token management and refresh

6. **CI/CD Integration**
   - Automated CLI builds and releases
   - Multi-platform binaries (linux/darwin/windows)
   - Run CLI tests in CI pipeline

7. **Documentation Generation**
   - `cobra gen man` for man pages
   - `cobra gen docs` for markdown documentation

8. **Extended CLI Features**
   - Output formatting options (json, yaml, table)
   - Progress indicators for long operations
   - Interactive mode for complex workflows
   - Batch operations support

## References

- [Protobuf CLI Recipe Discussion](Previous context about buf vs Bazel approaches)
- [Google's protoc-gen-go_cli](https://pkg.go.dev/github.com/googleapis/gapic-generator-go/cmd/protoc-gen-go_cli)
- [Bazel Proto Rules](https://github.com/bazelbuild/rules_proto)
- [Cobra CLI Framework](https://github.com/spf13/cobra)

## Conclusion

Successfully implemented a proto-first CLI generation strategy that:
- Maintains hermetic Bazel builds
- Eliminates circular dependencies
- Provides type-safe service access
- Follows the single source of truth principle

The pure Bazel approach (Option B) proved superior to the Buf-based approach (Option A) for this monorepo architecture, as it keeps all code generation within Bazel's dependency graph.