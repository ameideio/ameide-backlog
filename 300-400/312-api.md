# 310 – Public API Enablement

## Overview
- **Problem**: External tenants lack a stable REST/GraphQL contract, self-service credentials, or guardrails to safely consume the platform APIs.
- **Vision**: Deliver a public-facing API surface layered on top of existing Connect/gRPC services, backed by self-service onboarding, policy enforcement, and operational readiness.
- **Primary Owners**: Platform API team (design & façade), Identity & Access (auth flows), SRE (capacity & observability).

## Foundations in Place
- Envoy Gateway already fronts all ingress traffic with TLS termination and listener segmentation (`gitops/ameide-gitops/sources/values/env/local/apps/platform/gateway.yaml`).
- Core domain logic is exposed via Connect/gRPC services (e.g., platform, graph, threads) with shared protobuf contracts under `services/*`.
- Keycloak provides OIDC realms, clients, and session management (`infra/kubernetes/environments/local/infrastructure/keycloak.yaml`).
- Inference gateway demonstrates a tenant-aware control plane pattern (`services/inference_gateway/README.md`).

## Identified Gaps
1. **Consumer Contract** – No REST or GraphQL façade; external clients must speak internal Connect/gRPC protocols.
2. **Tenant Onboarding** – No UI or automation for API key provisioning or client credential management.
3. **Traffic Policy** – Rate limiting, quota, and auth interceptors only exist for inference workloads.
4. **Operational Readiness** – Missing SLAs, change-management policy, and capacity validation for shared clusters.

## Scope & Deliverables
1. **API Façade**
   - Define public REST/GraphQL schema for Organizations, Teams, Repository entities.
   - Implement façade service (BFF/adapter) composing existing Connect handlers.
   - Publish OpenAPI/GraphQL specs with versioning and error model guidance.
2. **Tenant Credential Management**
   - Extend platform UI for API client creation, key rotation, and role assignment through Keycloak.
   - Automate client provisioning workflows (naming, scopes, expiry policies).
3. **Gateway Policy Hardening**
   - Apply authZ enforcement, rate limits, and structured logging across all public routes.
   - Standardize tracing headers and request IDs for downstream correlation.
4. **Operational Readiness**
   - Define SLAs/SLOs, incident playbooks, and changelog cadence.
   - Run load & security testing; document capacity guardrails and scaling plans.

## Milestones
| Milestone | Target | Exit Criteria |
|-----------|--------|---------------|
| M1 – Contract Draft | T+2 weeks | Public API schema reviewed; façade spike against staging data. |
| M2 – Auth Self-Service | T+4 weeks | Tenants can create & rotate credentials via UI; audit logs captured. |
| M3 – Policy Enforcement | T+6 weeks | Envoy routes enforce auth, quotas, and observability for new endpoints. |
| M4 – Launch Readiness | T+8 weeks | Load test sign-off, runbooks published, beta tenants onboarded. |

## Metrics & Tracking
- Tenant activation rate and credential utilization.
- Error budgets for public endpoints vs. SLO targets.
- Request success latency p95/p99 through Envoy.
- Rate limit or policy enforcement events per tenant.

## Risks & Mitigations
- **Protocol Drift**: Internal proto changes could break façade mapping → enforce contract tests and versioned adapters.
- **Credential Leakage**: Store API keys hashed; integrate with Keycloak secret policies and audit logging.
- **Resource Contention**: Shared infra (DB, Kafka, Redis) may saturate under public load → reserve capacity budgets, add autoscaling rules.
- **Security Gaps**: New surface may expose attack vectors → conduct threat modeling and security review before GA.

## Open Questions
- What level of tenant isolation (per-tenant rate limits, data residency) is required for GA?
- Do we need a developer portal experience beyond the platform UI (docs, SDK distribution)?
- Should we adopt MCP or similar for LLM agents alongside REST/GraphQL in the initial release?
