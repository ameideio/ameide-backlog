## Ameide PR Preview Environments on Argo CD

### Normative specification (v1, closed)

### 0. Scope and invariants

**0.1 Preview definition**
A “preview environment” is the deterministic set of Argo CD Applications created for a GitHub Pull Request and deployed into exactly one Kubernetes namespace:

* Namespace name format: `pr-ameide-<PR_NUMBER>`
* Namespace is ephemeral
* Namespace is labeled so cluster policy can identify it as preview-managed

**0.2 Preview is apps-tier**
A preview deploys the **apps-tier set** (components in rollout phases `610–650`) into the PR namespace while reusing the base environment infra/data/observability. In Ameide, the apps-tier set explicitly includes the **primitives controllers/CR instances** (the `ameide.io/*` resources under `environments/_shared/components/apps/primitives/**`) as well as the apps runtimes and web surfaces. This matches the “apps-tier previews that reuse infra” requirement stated in the doc.

**0.2.1 Reuse shared entrypoints (avoid hostname conflicts)**
Some components in the repo exist to expose shared services on stable hostnames (e.g. `auth.<env>.ameide.io`, `evals.<env>.ameide.io`). These MUST be reused from the base environment and MUST NOT be redeployed into preview namespaces, because they would compete for the same hostnames on the shared Gateway.

**0.3 PR input trust model**
PR input is treated as untrusted for cluster safety. The only PR-derived values used to render cluster objects are:

* `PR_NUMBER` (integer)
* `HEAD_SHA` (string)

No branch names, titles, labels (except as a boolean gate), or other free text are included in any resource names, destinations, or project selection.

This aligns with Argo CD’s stated security posture that ApplicationSets are privileged and must be admin-owned, and that templating project fields is dangerous if untrusted users can open PRs.

---

## 1. Argo CD policy model

### 1.1 AppProject constraints

**AppProject `previews` (namespaced-only workloads):**

* `spec.sourceRepos` MUST allow only:

  * the GitOps repo that contains charts/values/components for apps-tier and preview baseline
  * (if used) the Helm chart repository/OCI registry for charts
* `spec.destinations` MUST allow only:

  * `server: https://kubernetes.default.svc`
  * `namespace: pr-ameide-*` (wildcard globbing is supported)
* `spec.clusterResourceWhitelist` MUST be empty.
  This is required because Argo CD AppProject cluster-scoped allow/deny is by `{group, kind}` only, so allowing `Namespace` would allow creation/deletion of **any** namespace.
* `spec.namespaceResourceWhitelist` MUST be an explicit allowlist containing **only** the kinds required by apps-tier charts and preview baseline (see §7.2 for the exact list).

**AppProject `previews-system` (namespace lifecycle only):**

* `spec.sourceRepos` MUST allow only the GitOps repo.
* `spec.destinations` MUST allow only:

  * `server: https://kubernetes.default.svc`
  * `namespace: argocd` (system apps target argocd as a destination namespace; they still apply cluster-scoped resources)
* `spec.clusterResourceWhitelist` MUST allow exactly one kind:

  * `group: ""`
  * `kind: Namespace`
* `spec.namespaceResourceWhitelist` MUST be empty.

**Control-plane safety rule**
No preview AppProject destination may include the Argo CD control-plane namespace. Argo CD explicitly warns that allowing deployments into the Argo CD install namespace grants admin-level access.

---

## 2. Namespace lifecycle (closed and safe)

### 2.1 Creation

Namespaces are created only by a GitOps-owned ApplicationSet:

* File: `argocd/applicationsets/preview-namespaces.yaml`
* Project: `previews-system`
* Generator: GitHub Pull Request generator (label-gated, see §5)

The namespace manifest MUST be rendered from **GitOps** source, never from PR source.

Namespace manifest MUST include labels:

* `ameide.io/managed-by: preview`
* `ameide.io/preview-pr: "<PR_NUMBER>"`
* `ameide.io/environment: "<BASE_ENV>"` (see §6)
* `gateway-access: allowed` (for Gateway API route attachment, see §6.3)
* `kubernetes.io/metadata.name: pr-ameide-<PR_NUMBER>` (automatically set by K8s but must not be overridden)

### 2.2 Deletion

**Argo CD MUST NOT delete preview namespaces automatically.**
Reason: vendor guidance treats namespaces as critical resources and provides “confirm” mechanisms for prune/delete; in previews, automated deletion is required, but must be centralized and audited.

Therefore:

* The namespace Application generated by `preview-namespaces.yaml` MUST NOT be configured to delete resources on Application deletion:

  * do not add the resources finalizer (`resources-finalizer.argocd.argoproj.io`)
  * do not enable automated prune

**Namespace deletion is performed only by the janitor job**:

* Component: `environments/_shared/components/cluster/configs/preview-janitor/component.yaml` (already present per doc)
* Execution: cluster-scoped CronJob running in a system namespace
* Algorithm (must be implemented exactly):

  1. List namespaces where:

     * name matches `^pr-ameide-[0-9]+$`
     * label `ameide.io/managed-by=preview`
  2. For each candidate namespace, refuse deletion if any Argo CD `Application` in namespace `argocd` has `spec.destination.namespace == <candidate>`.
  3. Refuse deletion if namespace age is < `PREVIEW_ORPHAN_TTL_SECONDS` (default `300`).
  4. Delete the namespace (async / `--wait=false` is acceptable).

This provides deterministic cleanup without granting preview workloads cluster-scoped permissions, matching the doc’s “janitor” closure mechanism.

---

## 3. Namespacing contract for all workload manifests

All namespaced Kubernetes objects rendered by apps-tier charts and baseline MUST NOT target a fixed namespace.

Namespace targeting is done exclusively via:

* `Application.spec.destination.namespace` and
* the deploy tool’s namespace injection (Helm release namespace)

If a template sets `.metadata.namespace`, it MUST be derived from the deploy tool’s release namespace (e.g. `{{ .Release.Namespace }}`), not a fixed string.

This is explicitly called out in the doc as a footgun and is mandatory.

---

## 4. Multi-source rule (exactly two sources, vendor-correct)

The preview stack contains different “lanes” with different source models:

- `preview-baseline` Applications are Kustomize-only and use a single Git source (`argocd/previews/baseline-<BASE_ENV>/`).
- `preview-secrets` Applications MUST use exactly **two** sources and use the same vendor-documented safe pattern as `preview-apps` (Helm chart + values-only `$values` source).
- `preview-apps` Applications MUST use exactly **two** sources and must use Argo CD’s vendor-documented safe pattern:

  * Source A: Helm chart source (the chart itself)
  * Source B: values-only Git source with `ref: values` and **no `path`** (so it cannot render resources)

This is Argo CD’s documented “Helm value files from external Git repository” pattern; if `path` is not set on the `$values` source, Argo uses it solely as a values provider.

**Collision rule**
No preview Application is allowed to rely on multi-source “last wins” resource overrides. Argo CD warns that repeated resources are allowed but produce `RepeatedResourceWarning`, and “last source wins.” That behavior is forbidden in preview specs.

---

## 5. ApplicationSet PR generator (webhook + polling, vendor-aligned)

### 5.1 PR gating

All preview ApplicationSets MUST require the GitHub PR label: `preview`.

### 5.2 Webhook requirement (managed clusters)

Managed clusters MUST expose the ApplicationSet webhook endpoint and register it in GitHub:

* The ApplicationSet controller webhook endpoint is `/api/webhook`.
* This webhook server is **separate** from the Argo CD API server webhook configuration and must be exposed independently.

The cluster must provide an HTTPS route (Gateway API HTTPRoute or Ingress) that forwards:

* External path: `/api/applicationset-webhook`
* Internal upstream: `argocd-applicationset-controller` service
* Internal path: `/api/webhook`
* Port: `7000` (controller webhook server)

(Your doc already describes the intended HTTPRoute that rewrites to `/api/webhook`.)

### 5.3 Polling safety net (all clusters)

All PR generators poll by default; vendor docs state the default `requeueAfterSeconds` is **1800** (30 minutes).
All preview ApplicationSets MUST set an explicit polling safety net (webhooks fail), and it SHOULD be low enough to be usable during webhook outages:

* `requeueAfterSeconds: 300` (recommended default for managed clusters)

### 5.4 Local clusters

Local clusters MUST NOT use a public webhook (not reachable). Local overlays MUST patch:

* `requeueAfterSeconds: 60`

(Your doc already includes this behavior.)

### 5.5 Template hardening

All preview ApplicationSets MUST enable go templates and fail on missing keys:

* `goTemplate: true`
* `goTemplateOptions: ["missingkey=error"]`

All preview ApplicationSets MUST set `spec.template.spec.project` to a **fixed string** (never templated from PR fields). Vendor docs explicitly call out the risk of templating `project` when untrusted users can create PRs.

---

## 6. Base environment reuse (NetworkPolicy + Gateway API)

### 6.1 Base environment selection

* Managed clusters: `BASE_ENV = dev`
* Local clusters: `BASE_ENV = local`

### 6.2 Namespace labels for NetworkPolicy reuse

Preview namespaces MUST carry `ameide.io/environment=<BASE_ENV>` so the existing environment-isolation policies can allow intended traffic. Your doc calls this out as an explicit constraint. 

### 6.3 Gateway API route attachment

The base environment Gateway MUST restrict route attachment using `listeners[].allowedRoutes.namespaces.selector`, and preview namespaces MUST satisfy that selector label. The Gateway API guide describes this namespace-selector handshake as the correct cross-namespace routing pattern.

### 6.4 Service aliasing contract (reuse shared infra endpoints)

Apps-tier charts use stable in-namespace service names for shared infra (Postgres, Redis, MinIO, Temporal, Keycloak, OTEL, etc.). Preview namespaces do not run those infra services, so previews MUST provide namespaced “aliases” that forward to the base environment namespace.

Normative rule:

* `preview-baseline` MUST create `Service` objects of type `ExternalName` in the PR namespace that map stable names to base env FQDNs, e.g.:

  * `postgres-ameide-rw` → `postgres-ameide-rw.ameide-<BASE_ENV>.svc.cluster.local`
  * `redis`, `redis-master` → `redis.ameide-<BASE_ENV>.svc.cluster.local`, `redis-master.ameide-<BASE_ENV>.svc.cluster.local`
  * `data-minio` → `data-minio.ameide-<BASE_ENV>.svc.cluster.local`
  * `temporal-frontend` → `temporal-frontend.ameide-<BASE_ENV>.svc.cluster.local`
  * `keycloak` → `keycloak.ameide-<BASE_ENV>.svc.cluster.local`
  * `otel-collector` → `otel-collector.ameide-<BASE_ENV>.svc.cluster.local`

This enforces “reuse infra” while keeping the workload values contracts unchanged (no per-chart host overrides).

---

## 7. Preview stack layout (what exists, what must exist)

### 7.1 Required ApplicationSets (exactly four)

1. **`preview-namespaces`** (system lane)

   * Creates `Namespace/pr-ameide-<num>` and applies required labels
   * Project: `previews-system`
   * MUST NOT delete Namespace on Application deletion (no resources finalizer, no automated prune); janitor owns deletion

2. **`preview-baseline`** (namespaced baseline lane)

   * One Application per PR
   * Deploys `argocd/previews/baseline-<BASE_ENV>/` into `pr-ameide-<num>`
   * Project: `previews`
   * Automated sync with prune + selfHeal
   * Finalizer: `resources-finalizer.argocd.argoproj.io`

3. **`preview-secrets`** (namespaced shared-infra secrets lane)

   * One Application per PR
   * Deploys `sources/charts/foundation/operators-config/postgres_secrets` into `pr-ameide-<num>` to materialize DB credential Secrets via ESO
   * Project: `previews`
   * Automated sync with prune + selfHeal
   * Finalizer: `resources-finalizer.argocd.argoproj.io`

4. **`preview-apps`** (apps-tier lane)

   * Many Applications per PR: matrix generator = PRs × apps-tier component list
   * Deploys the same charts as stable apps-tier (including primitives `ameide.io/*`) but into `pr-ameide-<num>`
   * Project: `previews`
   * Automated sync with prune + selfHeal
   * Finalizer: `resources-finalizer.argocd.argoproj.io`
   * Passes `HEAD_SHA` as image selector value (see §8)

### 7.2 Preview AppProject namespace allowlist (exact list)

`previews` AppProject `namespaceResourceWhitelist` MUST include exactly:

* core:

  * `Service`
  * `ServiceAccount`
  * `ConfigMap`
  * `Secret`
  * `Endpoints` (if your charts produce them)
  * `PersistentVolumeClaim` (required by `www-ameide-platform` when persistence is enabled)
* apps:

  * `Deployment`
  * `StatefulSet`
* batch:

  * `Job`
  * `CronJob`
* rbac.authorization.k8s.io:

  * `Role`
  * `RoleBinding`
* networking.k8s.io:

  * `NetworkPolicy`
* gateway.networking.k8s.io:

  * `HTTPRoute`
  * `GRPCRoute`
* monitoring.coreos.com (if enabled by apps-tier charts):

  * `ServiceMonitor`
  * `PrometheusRule`
* gateway.envoyproxy.io (only if enabled by apps-tier charts):

  * `HTTPRouteFilter`
* external-secrets.io (if used by baseline):

  * `ExternalSecret`
  * `SecretStore` (namespaced only; ClusterSecretStore is cluster-scoped and forbidden in previews project)
* ameide.io (required: primitives are part of the apps-tier set in Ameide):

  * `Domain`
  * `Process`
  * `Agent`
  * `Integration`
  * `Projection`
  * `UISurface`

No other kinds are permitted.

### 7.2.1 Allowlist verification gate (required)

Because the allowlist is intentionally strict, we MUST make it mechanically correct.

Required: add a CI gate that renders the apps-tier preview manifests and compares the observed `(apiGroup, kind)` set against the `previews` AppProject allowlist. The gate MUST fail if:

- a rendered resource kind is not whitelisted, or
- a whitelisted kind is never rendered (stale allowlist).

This turns “we think the allowlist is right” into “the allowlist is provably correct”.

### 7.3 Sync option hardening (applies to preview-baseline, preview-secrets, preview-apps)

All preview Applications MUST set:

* `FailOnSharedResource=true` (fail the sync if a shared resource is found)
* `PruneLast=true` (prune only after other resources are healthy)
* `PrunePropagationPolicy=background`

---

## 8. Image publishing contract (non-GitOps) and preview image selection

### 8.1 Required publishing outputs

The CI publish pipeline for the apps-tier MUST produce:

1. OCI container images pushed to the registry for every apps-tier service, tagged:

   * `:<HEAD_SHA>`
2. A build manifest artifact containing:

   * image repository
   * tag (`HEAD_SHA`)
   * resolved digest (`sha256:...`)
   * build timestamp
3. A supply-chain artifact set for each image:

   * SBOM
   * provenance
   * signature

### 8.2 Preview consumption rule

Preview deployments MUST select images from the PR commit without letting the PR define Kubernetes objects.

Normative rule (current chart contract): each apps-tier chart uses `.Values.image.ref` (full image reference). Therefore each `preview-apps` generated Application MUST set:

* `helm.parameters: [{ name: "image.ref", value: "ghcr.io/ameideio/<SERVICE>:<HEAD_SHA>" }]`

Where `<SERVICE>` is the component/application name (or an explicit per-component override if image repository naming differs).

This keeps the PR surface area to “code/images only” and avoids letting PR branches define cluster objects.

### 8.3 Image repository mapping (required)

The image repository mapping MUST be deterministic and uniform across the apps tier:

- Default mapping: `<SERVICE>` = component name, and image repo is `ghcr.io/ameideio/<SERVICE>`.
- If an exception is required, it MUST be expressed as explicit component metadata in the GitOps inventory (not inferred from PR data) so `preview-apps` can apply it consistently.

---

## 9. Preview URL scheme (deterministic)

Preview URLs MUST be realized by the apps-tier charts that already define Gateway API resources, by injecting PR-scoped hostnames via `preview-apps` values/parameters.

For each PR, the following hostnames MUST exist (and differ from the base env hostnames):

* `www-pr-<PR_NUMBER>.<BASE_ENV>.ameide.io`
* `api-pr-<PR_NUMBER>.<BASE_ENV>.ameide.io`
* `platform-pr-<PR_NUMBER>.<BASE_ENV>.ameide.io`

Normative mapping to charts (current Ameide contracts):

- `www-pr-...` is served by `www-ameide` via `httproute.hostname`
- `platform-pr-...` is served by `www-ameide-platform` via `httproute.hostname`
- `api-pr-...` is served by `inference-gateway` via `grpcRoute.hostnames` (and/or `httproute.hostname` if/when HTTP is enabled)

All preview routes MUST attach to the base-environment Gateway using cross-namespace attachment (charts must set `gatewayNamespace` / `parentRefs.namespace`), and the preview namespace MUST satisfy the gateway’s `allowedRoutes.namespaces.selector` (via the `gateway-access=allowed` label).

This matches the DNS/cert constraint noted in the spec (avoid multi-label wildcards that don’t match `*.{env}.ameide.io`).

---

# Implementation plan (refactor-driven, no branches)

## Phase 1 — Make the spec canonical (doc refactor)

1. Replace `465-applicationset-architecture-preview-envs.md` with a **single** “Normative spec v1” that matches the above.
2. Delete every “Option A/Option B/choose one” block from the doc. Specifically remove the deploy-contract options and the namespace-strategy options that currently remain in the file.
3. Remove the contradictory line that claims implementation uses `CreateNamespace=true + managedNamespaceMetadata` as the closure, because the system-lane namespace lifecycle ApplicationSet already exists and is the only safe model under Argo’s `{group,kind}` cluster whitelist constraint.

## Phase 2 — Argo CD objects refactor (GitOps repo)

4. Ensure both AppProjects exist exactly as specified:

   * `argocd/projects/previews.yaml`
   * `argocd/projects/previews-system.yaml`
5. Update `preview-namespaces.yaml`:

   * project = `previews-system`
   * generated Application MUST NOT delete the Namespace (no resources finalizer, no automated prune)
   * source is GitOps-only
6. Split the current `argocd/applicationsets/preview.yaml` into:

   * `preview-baseline.yaml`
   * `preview-secrets.yaml`
   * `preview-apps.yaml`
     and delete `preview.yaml`.

## Phase 3 — Vendor-correct PR refresh wiring

7. Ensure ApplicationSet webhook exposure exists in managed clusters:

   * route external `/api/applicationset-webhook` → internal `/api/webhook` on the ApplicationSet controller
8. Register GitHub webhook:

   * send PR events
   * configure secret validation
9. Set `requeueAfterSeconds: 300` on all managed-cluster preview ApplicationSets.
10. Patch local overlay to `requeueAfterSeconds: 60` and no webhook dependency.

## Phase 4 — Apps-tier preview (matrix generator) + image contract

11. Implement `preview-apps.yaml` as a matrix generator:

    * PR generator (label `preview`)
    * Git file generator over apps-tier component definitions
    * filter rolloutPhase `610–650` (the apps-tier set)
12. For each generated Application:

    * destination namespace `pr-ameide-{{ .number }}`
    * two-source pattern:

      * Helm chart source
      * values-only ref source used solely for `$values/.../values.yaml`
    * set `helm.parameters` for image selection (e.g. `image.ref=ghcr.io/ameideio/<service>:{{ .head_sha }}`)

## Phase 5 — Secrets (closed posture)

13. Relax Vault preview policy to allow reuse of *base environment* secrets (trade-off: less isolation, faster previews).
14. `preview-baseline` MUST materialize:

    * `ghcr-pull`
    * shared infra credentials required by apps-tier charts (e.g., `redis-auth`, `minio-root-credentials`, Keycloak admin bootstrap), via ExternalSecrets.
15. `preview-secrets` MUST materialize per-app DB credentials Secrets (Vault -> ESO -> Secret) so apps-tier Deployments can start.

## Phase 6 — Cleanup and verification

16. Ensure `preview-janitor` CronJob runs cluster-wide and enforces the exact deletion algorithm in §2.2.
17. Verification gates:

    * PR open + label `preview` → namespaces + baseline + apps-tier Applications appear quickly (webhook)
    * PR close or label removal → apps-tier + baseline Applications deleted with cascading resource deletion (finalizer)
    * Namespace remains until janitor deletes (≥`PREVIEW_ORPHAN_TTL_SECONDS` and not referenced)

## Phase 7 — Enforcement gates (CI, required)

18. Add a CI gate that renders the preview apps-tier and verifies:

    * every rendered kind is allowed by the `previews` AppProject allowlist (§7.2)
    * no unexpected kinds appear (fail-fast on chart changes)

19. Add a CI gate that ensures no multi-source collisions are relied upon:

    * rendering must not intentionally produce duplicate resource identities where “last source wins”
    * treat `RepeatedResourceWarning` as a failure condition for previews
