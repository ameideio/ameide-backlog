# Ameide BPMN Execution Profile v1 and Process Primitive Compiler v1

> **DEPRECATED (2026-01-12):** This is the v1 spec for **BPMN → compiler → Temporal runner**.  
> New direction: BPMN-authored processes execute on Zeebe; Ameide extensions become design-time worker contracts (no transpilation).  
> See `backlog/511-process-primitive-scaffolding-v2.md`.

Complete software implementation specification with zero open decisions

This document is the **normative**, **fully closed** implementation specification for:

1. the **Ameide BPMN extension profile** (execution profile v1),
2. the **BPMN linter/compiler** (Go, self-contained), and
3. the **generated Process primitive** (Temporal worker + ingress router) produced from BPMN.

It **supersedes** the “direction” wording in the backlog documents and removes every ambiguity by making each behavior either **required** or **rejected** by validation.  

---

## 0. Normative language

The key words **MUST**, **MUST NOT**, **REQUIRED**, **FORBIDDEN** are used as strict requirements.

This specification contains **no** “nice-to-have” behaviors: any case not explicitly defined here is **FORBIDDEN** and the linter/compiler **MUST** reject it.

---

## 1. Scope

### 1.1 In scope

This specification defines:

* The **only supported BPMN subset** for compilation.
* The **only supported Ameide extension elements** and their XML shapes.
* The **only supported wait semantics** (receive/catch message waits only).
* A **single normalized envelope** contract for inbound signaling.
* The **Go implementation requirements** for:

  * the linter,
  * the compiler (BPMN → IR → codegen),
  * the generated Process primitive scaffold,
  * the runtime workflow behavior on Temporal.

### 1.2 Out of scope

Anything not defined here is FORBIDDEN, including (non-exhaustive):

* any BPMN engine compatibility assumptions,
* any general expression language (FEEL, scripts, JUEL, XPath, etc.),
* boundary events, event subprocesses, compensation, transactions,
* timer semantics,
* parallel gateways / token concurrency,
* multi-instance / loop characteristics,
* call activities.

---

## 2. Repository contract for a Process primitive

A Process primitive generated by the CLI **MUST** have this repository structure (additional files are allowed; this structure must exist):

```text
primitives/process/<name>/
├── README.md
├── catalog-info.yaml
├── go.mod
├── Dockerfile.dev
├── Dockerfile.main
├── bpmn/
│   ├── process.bpmn
│   ├── policies.yaml
│   └── compile.lock.json
├── cmd/
│   ├── worker/
│   │   └── main.go
│   └── ingress/
│       └── main.go
└── internal/
    ├── workflows/
    │   ├── workflow.go                     # human-owned: glue + TODO hooks
    │   └── workflow_gen.go                 # generated: compiled state machine
    ├── activities/
    │   ├── activities.go                   # human-owned: implementations
    │   └── activities_gen.go               # generated: interfaces + registration
    ├── ingress/
    │   ├── router.go                       # human-owned: bus client wiring
    │   └── router_gen.go                   # generated: message filter + dispatch
    ├── process/
    │   └── state.go                        # human-owned: state helpers
    └── tests/                              # optional (repo conventions / future harness)
```

### 2.1 Generated file ownership rule

The compiler **MUST** write and overwrite only files that end with `_gen.go` and `bpmn/compile.lock.json`.

The compiler **MUST NOT** modify any other file.

---

## 3. CLI behavior contract

### 3.1 Scaffold command

The CLI **MUST** support this command, with exactly these flags:

```bash
ameide primitive scaffold --kind process --name <name>
```

This command **MUST** generate the directory structure in §2 and the initial `bpmn/process.bpmn` template file, `bpmn/policies.yaml`, and a runnable `cmd/worker` + `cmd/ingress`.

GitOps wiring for the Process primitive is handled via the `ameide-gitops` CI scaffolding workflow (670), not by local `--include-gitops` writes.

### 3.2 Compile command

There is **no** standalone compile command in v1.

Instead, compilation is an internal step invoked by:

* `ameide primitive scaffold --kind process ...` (writes generated outputs), and
* `ameide primitive verify --kind process --name <name> --mode repo` (compares generated outputs; no writes).

Note: Phase 0 of `ameide test` is the workspace-wide gate (repo-wide + all primitives).

The compiler behavior is:

* Reads BPMN from: `bpmn/process.bpmn`
* Reads policies from: `bpmn/policies.yaml`
* Runs lint (strict)
* Builds IR
* Generates all `_gen.go` files
* Writes `bpmn/compile.lock.json` **deterministically** (no timestamps or non-deterministic fields)

### 3.3 Verify command

The CLI **MUST** support:

```bash
ameide primitive verify --kind process --name <name> --mode repo
```

Behavior:

* Compiles to memory and compares against committed `_gen.go` files and `bpmn/compile.lock.json` (no writes).
* Fails if any generated artifact differs.

Exit status:

* `0` when repository is up to date.
* `1` when repository is out of date or invalid.

---

## 4. Supported BPMN subset (compileable language)

The compiler supports exactly one BPMN file per Process primitive: `bpmn/process.bpmn`.

### 4.1 BPMN document requirements

`bpmn/process.bpmn` MUST satisfy:

1. The root element is `bpmn:definitions`.
2. `xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL"` MUST be present.
3. `xmlns:ameide="https://ameide.io/schema/bpmn/extensions/v1"` MUST be present.
4. Exactly **one** `bpmn:process` MUST exist under `bpmn:definitions`.
5. That `bpmn:process` MUST have `isExecutable="true"`.
6. BPMN DI elements (`bpmndi:*`, `dc:*`, `di:*`) are allowed and are ignored by compilation and by definition digest calculation.

### 4.2 Supported BPMN element types

Only these BPMN element types participate in compilation:

* `bpmn:process`
* `bpmn:subProcess` (embedded)
* `bpmn:startEvent`
* `bpmn:endEvent`
* `bpmn:sequenceFlow`
* `bpmn:serviceTask`
* `bpmn:sendTask`
* `bpmn:userTask`
* `bpmn:receiveTask`
* `bpmn:intermediateCatchEvent` **with exactly one** `bpmn:messageEventDefinition`
* `bpmn:intermediateThrowEvent` **with exactly one** `bpmn:messageEventDefinition`
* `bpmn:exclusiveGateway`
* `bpmn:message`

Every other BPMN element type is FORBIDDEN and MUST cause a compile error.

### 4.3 Graph structure constraints

The graph MUST satisfy:

* Exactly one direct process-level `bpmn:startEvent`.
* Exactly one direct process-level `bpmn:endEvent`.
* Every node is reachable from the process start event (including subprocess internals).

Profile v1 does not define loop semantics (loop characteristics / multi-instance). Directed cycles are considered **unsupported** and will be rejected before v1 is considered complete. (Implementation note: cycle detection is not yet enforced in the compiler as of 2026-01.)

### 4.4 Sequence flow constraints

For each `bpmn:sequenceFlow`:

* `id`, `sourceRef`, and `targetRef` MUST exist.
* `sourceRef` and `targetRef` MUST reference nodes within the same `bpmn:process` (including embedded subprocesses).

For each node type:

* `bpmn:startEvent` MUST have at least 1 outgoing sequenceFlow.
* `bpmn:endEvent` MUST have at least 1 incoming sequenceFlow.
* `bpmn:serviceTask` MUST have at least 1 incoming sequenceFlow.
* `bpmn:sendTask` MUST have at least 1 incoming sequenceFlow.
* `bpmn:userTask` MUST have at least 1 incoming sequenceFlow.
* `bpmn:receiveTask` MUST have at least 1 incoming sequenceFlow.
* `bpmn:intermediateCatchEvent` MUST have at least 1 incoming sequenceFlow.
* `bpmn:intermediateThrowEvent` MUST have at least 1 incoming sequenceFlow.
* `bpmn:exclusiveGateway` MUST have at least 1 incoming and at least 1 outgoing sequenceFlow.
* `bpmn:subProcess` MUST have at least 1 incoming sequenceFlow.

### 4.5 Message waits

A message wait is expressed only by:

* `bpmn:receiveTask` that references a `bpmn:message`, OR
* `bpmn:intermediateCatchEvent` containing `bpmn:messageEventDefinition messageRef="..."`.

Any other wait shape is FORBIDDEN.

### 4.6 Subprocess compilation (inline semantics)

Each embedded `bpmn:subProcess` is compiled as a standard BPMN container with explicit runtime structure:

* The subprocess MUST contain exactly one direct `bpmn:startEvent` with no event definitions (noneStartEvent).
* The subprocess MUST contain at least one direct `bpmn:endEvent` (noneEndEvent).
* Entering the subprocess activates its internal startEvent.
* Reaching a subprocess internal endEvent continues along the outgoing flows of the subprocess container.
* The subprocess container itself is emitted as a runtime step (for container scoping and completion checks).

---

## 5. Ameide namespace, placement, and XML shapes

### 5.1 Namespace

* Namespace URI: `https://ameide.io/schema/bpmn/extensions/v1`
* Prefix: `ameide`

### 5.2 Placement rule

Every Ameide element MUST appear under `bpmn:extensionElements`.

Any Ameide element outside `bpmn:extensionElements` is FORBIDDEN.

---

## 6. Normalized inbound envelope (runtime signal payload)

All inbound messages delivered to workflows MUST be carried as a single normalized envelope type:

### 6.1 Envelope fields (required)

The envelope is a JSON/proto-serializable structure with these fields:

| Field name        | Type   | Meaning                                          |
| ----------------- | ------ | ------------------------------------------------ |
| `workflow_id`     | string | Temporal WorkflowID target                       |
| `message_name`    | string | Logical message name (matches BPMN message name) |
| `message_id`      | string | Unique delivery id for dedupe                    |
| `correlation_key` | string | Correlation key for subscription matching        |
| `tenant_id`       | string | Tenant scope                                     |
| `correlation_id`  | string | Trace correlation id                             |
| `causation_id`    | string | Causation id                                     |
| `traceparent`     | string | W3C traceparent                                  |
| `payload_bytes`   | bytes  | Opaque payload (process-specific decode)         |

### 6.2 Canonical field names

The exact snake_case names above are mandatory in serialization form.

### 6.3 Routing rule

Ingress MUST call Temporal `SignalWithStart` targeting `workflow_id`.

Ingress MUST use workflow type from `ameide:workflowDefinition.workflowType`.

Ingress MUST send the envelope as the payload of a single signal name:

* Signal name: `ameide.envelope.v1`

### 6.4 Correlation and dedupe binding

Inbound correlation key is ALWAYS read from the normalized envelope field:

* `correlation_key`

Inbound dedupe id is ALWAYS read from:

* `message_id`

There is no per-subscription configuration for where correlation key is extracted.

---

## 7. Template grammar v1

Templates are used in Ameide attributes that end with `Template`.

### 7.1 Syntax

A template is a UTF-8 string containing zero or more placeholders of the form:

* `${<variable>}`

Backslash escaping is supported:

* `\${` is treated as literal `${`.

Any other escape handling is FORBIDDEN.

### 7.2 Variables (workflow context)

Templates evaluated inside workflow execution (task idempotency keys, wait correlation keys) support these variables:

* `${process_instance_id}` → Temporal WorkflowID
* `${process_run_id}` → Temporal RunID
* `${step_id}` → BPMN element id of the currently executing step
* `${step_instance_id}` → deterministic runtime instance id (see §12.3)
* `${state.<path>}` → read from workflow state at `<path>`

### 7.3 Evaluation failure

During compilation:

* Any placeholder that is not one of the variables above is a compile error.
* Any `${state.<path>}` whose `<path>` fails Path grammar is a compile error.

During runtime:

* Any `${state.<path>}` that resolves to missing causes deterministic workflow failure with error name: `AmeideTemplateMissingPath`.
* Any evaluated template producing an empty string causes deterministic workflow failure with error name: `AmeideTemplateEmpty`.

---

## 8. Path grammar v1

### 8.1 Grammar

A path is a dot-separated sequence of identifiers:

* identifier: `[A-Za-z_][A-Za-z0-9_]*`
* path: `identifier("."identifier)*`

Array indexing is FORBIDDEN.

### 8.2 State roots

Paths used in this specification are rooted into one of these root objects:

* `state` (workflow state)
* `request` (activity request object constructed for a task)
* `result` (activity result object returned by an activity)

Root selection is fixed per attribute type:

* `ameide:subscription.correlationKeyTemplate` MUST use only `${state.<path>}`.
* `ameide:taskDefinition.idempotencyKeyTemplate` MUST use only `${state.<path>}` plus workflow variables.
* `ameide:ioMapping/input.source` MUST start with `state.`
* `ameide:ioMapping/input.target` MUST start with `request.`
* `ameide:ioMapping/output.source` MUST start with `result.`
* `ameide:ioMapping/output.target` MUST start with `state.`
* `ameide:subscription.messageIdPath` MUST equal `message_id` exactly.

Any violation is a compile error.

---

## 9. Ameide extension elements (required everywhere)

### 9.1 Process-level `ameide:workflowDefinition`

Placement: `bpmn:process/bpmn:extensionElements`

This element MUST exist exactly once.

Attributes:

* `definitionId` REQUIRED
* `workflowType` OPTIONAL (recommended: equals the BPMN process id, `bpmn:process@id`)
* `workflowIdTemplate` REQUIRED

Constraints:

* `workflowIdTemplate` may reference only `${state.<path>}` placeholders (no general expression language).

### 9.2 Work binding `ameide:taskDefinition`

Placement: on every executable automated node (`bpmn:serviceTask`, `bpmn:sendTask`, and message `bpmn:intermediateThrowEvent`) under `bpmn:extensionElements`.

This element MUST exist exactly once per task.

Attributes:

* `type` REQUIRED (string, non-empty)
* `idempotencyKeyTemplate` OPTIONAL
* `policyRef` REQUIRED

Idempotency template constraints:

* If set, `idempotencyKeyTemplate` MUST NOT include any placeholder other than those allowed in §7.2.

### 9.3 Static metadata `ameide:taskHeaders`

Placement: on every `bpmn:serviceTask` and `bpmn:sendTask`.

This element MUST exist exactly once per task and may contain zero headers.

Child element:

* `ameide:header` with attributes:

  * `key` REQUIRED, regex: `[a-z0-9][a-z0-9_.-]{0,63}`
  * `value` REQUIRED, non-empty

### 9.4 Deterministic IO mapping `ameide:ioMapping`

Placement: on every `bpmn:serviceTask` and `bpmn:sendTask`.

This element MUST exist exactly once per task.

Children are evaluated strictly in document order:

* `ameide:input source="..." target="..."`
* `ameide:output source="..." target="..."`

Both attributes are REQUIRED and MUST satisfy §8.2 root rules.

Mapping semantics:

* For each input mapping, read value from workflow state at `source`, then assign to request at `target`.
* For each output mapping, read value from activity result at `source`, then assign to workflow state at `target`.
* If `source` does not exist, the compiler-generated code MUST delete the `target` path (unset).

### 9.5 Wait correlation `ameide:subscription`

Placement: on every `bpmn:message/bpmn:extensionElements`.

Each referenced `bpmn:message` MUST contain exactly one `ameide:subscription`.

Attributes:

* `correlationKeyTemplate` REQUIRED
* `messageIdPath` REQUIRED and MUST equal `message_id`

Message name binding:

* The message name used for matching is `bpmn:message@name`.
* `bpmn:message@name` MUST be non-empty.
* All `bpmn:message@name` values MUST be unique within the file.

### 9.6 Human gate binding `ameide:updateDefinition`

Placement: on every `bpmn:userTask/bpmn:extensionElements`.

This element MUST exist exactly once per userTask.

Attributes:

* `name` REQUIRED and MUST equal `Update_<userTaskId>` exactly.

Any other attribute is FORBIDDEN.

---

## 10. Wait node semantics (runtime)

### 10.1 Wait node binding to message

For `bpmn:intermediateCatchEvent`:

* It MUST contain exactly one `bpmn:messageEventDefinition`.
* That definition MUST have `messageRef` referencing a `bpmn:message` id.
* The referenced `bpmn:message` MUST contain an `ameide:subscription`.

For `bpmn:receiveTask`:

* It MUST have attribute `messageRef` referencing a `bpmn:message` id.
* The referenced `bpmn:message` MUST contain an `ameide:subscription`.

### 10.2 Match rule

When a workflow enters a wait node W bound to message M:

* Expected message name = `M.name`
* Expected correlation key = evaluate `subscription.correlationKeyTemplate` in workflow context

An inbound envelope matches W if and only if:

* `envelope.message_name == expected message name`
* `envelope.correlation_key == expected correlation key`

### 10.3 Dedupe rule

For a wait node W:

* The workflow MUST maintain a set of seen `message_id` values (workflow-local, persisted).
* If an inbound envelope has `message_id` and that `message_id` has already been seen, it MUST be ignored (it MUST NOT complete any wait).
* The first matching envelope with an unseen `message_id` completes the wait and records the `message_id` as seen.

This enables sequential waits on the same `(message_name, correlation_key)` while preventing a single delivery from satisfying multiple wait states.

---

## 11. Task execution model (v1)

In profile v1, there is no task “implementation mode” (no delegated/domainCommand variants in the schema):

* All executable work nodes (`serviceTask`, `sendTask`, message `intermediateThrowEvent`) compile to Temporal Activities.
* Long waits are modeled as explicit BPMN wait nodes and compile to Workflow-level waits (Signals/Updates), not blocked Activities.

---

## 12. Compiler IR and digests

### 12.1 IR v1 contents

The compiler MUST build an IR containing:

* process id
* workflowType
* all nodes with:

  * id, name, BPMN type
  * taskDefinition (for tasks)
  * ioMapping (for tasks)
  * taskHeaders (for tasks)
  * updateDefinition (for user tasks)
  * message binding (for waits)
* all sequenceFlow edges
* all messages with:

  * id, name
  * subscription

### 12.2 Canonical digest algorithm

`ameide:workflowDefinition@definitionId` is a required, author-controlled identifier (version/checksum) that MUST change when semantics change.

In addition, the compiler computes a stable IR digest (`ir_digest`) from a canonical serialization of the compiled IR. This digest:

* is deterministic for a given BPMN + policies input,
* is written to `bpmn/compile.lock.json`,
* is NOT required to equal `workflowDefinition.definitionId` (it exists to detect drift and aid debugging).

Canonicalization details are intentionally mechanical (not a “semantic” authoring surface) and are treated as a compiler implementation detail; the resulting `ir_digest` value is the contract exported to the repo via `bpmn/compile.lock.json`.

### 12.3 Step instance id

The runtime `step_instance_id` MUST be a stable, monotonic counter per `step_id` within a workflow run, formatted as:

* `<step_id>/<n>` where `n` starts at `1` and increments each time the step is scheduled.

---

## 13. Generated Go code requirements

### 13.1 Packages

Generated files MUST be in these packages:

* `internal/workflows/*_gen.go` uses package `workflows`
* `internal/activities/*_gen.go` uses package `activities`
* `internal/ingress/*_gen.go` uses package `ingress`
* `internal/process/*_gen.go` uses package `process`

### 13.2 Worker registration

`cmd/worker/main.go` MUST:

* create a Temporal worker with:

  * Task queue name from environment variable `TEMPORAL_TASK_QUEUE`
  * Namespace from environment variable `TEMPORAL_NAMESPACE`
* register the generated workflow function:

  * name = `workflowType` (string)
* register generated activity function stubs:

  * each activity registered name = `taskDefinition.type`

### 13.3 Workflow function signature

The generated workflow MUST have signature:

```go
func ProcessWorkflow(ctx workflow.Context, input process.WorkflowInput) error
```

Where:

```go
type WorkflowInput struct {
    ProcessDefinitionID string
}
```

The workflow MUST validate:

* `input.ProcessDefinitionID == ameide:workflowDefinition.definitionId`

If mismatch, workflow MUST fail deterministically with error name: `AmeideDefinitionMismatch`.

### 13.4 Signal handling

The workflow MUST:

* receive inbound envelopes on signal name `ameide.envelope.v1`
* append envelopes into a deterministic in-memory buffer stored in workflow state

Buffer retention rule:

* The buffer MUST retain all unmatched envelopes until consumed by a wait node.
* When an envelope is consumed by a wait node, it MUST be removed from buffer.

### 13.5 Activity invocation

For each task node:

* Build `request` as `map[string]any`.
* Apply input ioMapping in order.
* Compute idempotency key via template.
* Load ActivityOptions from the resolved policyRef.
* Execute the Temporal Activity registered for the BPMN step id (the generated `ActivityName_<stepId>` constant). `taskDefinition.type` is passed as metadata (`TaskType`) to the Activity implementation; it is not used for dispatch.
* Decode activity result into `map[string]any` named `result`.
* Apply output ioMapping in order.
* Advance to next node.

### 13.6 User task update

For each userTask node:

* Register an Update handler named `Update_<userTaskId>` by default (or `ameide:updateDefinition@name` if set).
* The Update handler input type MUST be:

```go
type GateDecision struct {
    Decision string `json:"decision"`
    Reason   string `json:"reason"`
}
```

Semantics (v1):

* The Update MUST require `Decision` to be non-empty.
* The workflow MUST accept at most one decision per gate (reject duplicates).
* The workflow consumes the decision when it reaches the userTask step and uses it to select the outgoing sequence flow.

---

## 14. Policies catalog

### 14.1 Location

The policy catalog MUST be a YAML file at:

* `bpmn/policies.yaml`

### 14.2 Schema (required fields)

The YAML MUST contain:

```yaml
version: 1
policies:
  - name: <policyRef>
    schedule_to_close_timeout_seconds: <int>
    start_to_close_timeout_seconds: <int>
    retry:
      maximum_attempts: <int>
      initial_interval_seconds: <int>
      maximum_interval_seconds: <int>
      backoff_coefficient: <float>
      non_retryable_error_types:
        - <string>
        - ...
```

Constraints:

* `version` MUST equal `1`.
* Every integer timeout MUST be > 0.
* `maximum_attempts` MUST be >= 1.
* `backoff_coefficient` MUST be >= 1.0.
* `name` values MUST be unique.

### 14.3 Resolution

For every `ameide:taskDefinition.policyRef` referenced in BPMN:

* An exact matching policy name MUST exist in the catalog.
* The compiler MUST emit resolved values into generated Go code as constants.

---

## 15. Ingress runtime requirements

`cmd/ingress/main.go` MUST:

* read from a bus consumer (implementation is human-owned in `internal/ingress/router.go`)
* for each inbound envelope:

  * validate all required envelope fields are non-empty
  * call Temporal `SignalWithStart`:

    * WorkflowID = `envelope.workflow_id`
    * WorkflowType = `workflowType`
    * SignalName = `ameide.envelope.v1`
    * SignalArg = the envelope
    * WorkflowIDReusePolicy = `AllowDuplicateFailedOnly`
    * WorkflowIDConflictPolicy = `UseExisting`

On validation failure of an envelope, ingress MUST terminate the process with non-zero exit code.

---

## 16. Required tests

The scaffold MUST include tests that compile and run under `go test ./...`.

### 16.1 Compile determinism test

`internal/tests/compile_test.go` MUST:

* run the compiler in-memory on `bpmn/process.bpmn`
* compare the produced `_gen.go` and `compile.lock.json` bytes to repository files
* fail if any mismatch exists

### 16.2 Workflow skeleton execution test

`internal/tests/<name>_workflow_test.go` MUST:

* start Temporal test environment
* register generated workflow and stub activities
* send an envelope that drives the workflow through the entire BPMN path:

  * for each wait node, send a matching envelope with correct `(message_name, correlation_key)`
* assert workflow completes successfully

The test MUST fail if any human-owned TODO remains unimplemented in a way that blocks compilation.

---

## 17. Complete XSD (namespace elements only)

The Ameide XSD MUST be exactly this (file path: `bpmn/ameide-bpmn-v1.xsd` inside the CLI repo, embedded in the binary for validation):

```xml
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  targetNamespace="https://ameide.io/schema/bpmn/extensions/v1"
  xmlns:ameide="https://ameide.io/schema/bpmn/extensions/v1"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified">

  <xs:simpleType name="path">
    <xs:restriction base="xs:string">
      <xs:pattern value="[A-Za-z_][A-Za-z0-9_]*(\.[A-Za-z_][A-Za-z0-9_]*)*"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:element name="workflowDefinition" type="ameide:workflowDefinitionType"/>
  <xs:complexType name="workflowDefinitionType">
    <xs:attribute name="definitionId" type="xs:string" use="required"/>
    <xs:attribute name="workflowType" type="xs:string" use="required"/>
    <xs:attribute name="workflowIdTemplate" type="xs:string" use="required"/>
  </xs:complexType>

  <xs:simpleType name="messageIdPath">
    <xs:restriction base="xs:string">
      <xs:enumeration value="message_id"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:element name="taskDefinition" type="ameide:taskDefinitionType"/>
  <xs:complexType name="taskDefinitionType">
    <xs:attribute name="type" type="xs:string" use="required"/>
    <xs:attribute name="idempotencyKeyTemplate" type="xs:string" use="optional"/>
    <xs:attribute name="policyRef" type="xs:string" use="required"/>
  </xs:complexType>

  <xs:element name="taskHeaders" type="ameide:taskHeadersType"/>
  <xs:complexType name="taskHeadersType">
    <xs:sequence>
      <xs:element name="header" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:attribute name="key" type="xs:string" use="required"/>
          <xs:attribute name="value" type="xs:string" use="required"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:element name="ioMapping" type="ameide:ioMappingType"/>
  <xs:complexType name="ioMappingType">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="input" type="ameide:mappingEntryType"/>
      <xs:element name="output" type="ameide:mappingEntryType"/>
    </xs:choice>
  </xs:complexType>

  <xs:complexType name="mappingEntryType">
    <xs:attribute name="source" type="ameide:path" use="required"/>
    <xs:attribute name="target" type="ameide:path" use="required"/>
  </xs:complexType>

  <xs:element name="subscription" type="ameide:subscriptionType"/>
  <xs:complexType name="subscriptionType">
    <xs:attribute name="correlationKeyTemplate" type="xs:string" use="required"/>
    <xs:attribute name="messageIdPath" type="ameide:messageIdPath" use="required"/>
  </xs:complexType>

  <xs:element name="updateDefinition" type="ameide:updateDefinitionType"/>
  <xs:complexType name="updateDefinitionType">
    <xs:attribute name="name" type="xs:string" use="optional"/>
  </xs:complexType>

</xs:schema>
```

---

## 18. Summary of closed decisions

This v1 spec fixes all prior ambiguities by hard requirements:

* correlation extraction: always `envelope.correlation_key`
* dedupe id extraction: always `envelope.message_id`
* waits: only `receiveTask` and `intermediateCatchEvent(message)`
* subscriptions: only on `bpmn:message`
* process identity: definition digest from IR canonical bytes; pinned in BPMN via `workflowDefinition.definitionId`
* workflow type: recommended to equal BPMN process id (enforced by conventions, not required by the compiler)
* user tasks: Updates named `Update_<userTaskId>` by default (overridable with `ameide:updateDefinition@name`)
* policies: always from `bpmn/policies.yaml` with fully specified fields
* compiler outputs: only `_gen.go` files and `compile.lock.json`

If you want, I can convert this exact spec into:

* a single `SPEC.md` file to live beside the generator code, and
* a checklist test plan mapping each MUST to a unit/integration test, so the implementation stays locked to the contract.
