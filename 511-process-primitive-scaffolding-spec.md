# Ameide BPMN Execution Profile v1 and Process Primitive Compiler v1

Normative software implementation specification (profile + compiler + scaffold)

This document is the **normative** implementation specification for:

1. the **Ameide BPMN extension profile** (execution profile v1),
2. the **BPMN linter/compiler** (Go, self-contained), and
3. the **generated Process primitive** (Temporal worker + ingress router) produced from BPMN.

It defines a strict, Temporal-targeted BPMN profile intended to keep BPMN authoring Flowable/Camunda-friendly while remaining compilable into deterministic Temporal workflows.

---

## 0. Normative language

The key words **MUST**, **MUST NOT**, **REQUIRED**, **FORBIDDEN** are used as strict requirements.

This specification contains **no** “nice-to-have” behaviors: any case not explicitly defined here is **FORBIDDEN** and the linter/compiler **MUST** reject it.

---

## 1. Scope

### 1.1 In scope

This specification defines:

* The **only supported BPMN subset** for compilation.
* The **only supported Ameide extension elements** and their XML shapes.
* The **only supported wait semantics** (message waits and timer waits).
* A **single normalized envelope** contract for inbound signaling.
* The **Go implementation requirements** for:

  * the linter,
  * the compiler (BPMN → IR → codegen),
  * the generated Process primitive scaffold,
  * the runtime workflow behavior on Temporal.

### 1.2 Out of scope

Anything not defined here is FORBIDDEN, including (non-exhaustive):

* any BPMN engine compatibility assumptions,
* any general expression language (FEEL, scripts, JUEL, XPath, etc.),
* boundary events, event subprocesses, compensation, transactions,
* multi-instance / loop characteristics,
* call activities.

---

## 2. Repository contract for a Process primitive

A Process primitive generated by the CLI **MUST** have this repository structure (additional files are allowed; this structure must exist):

```text
primitives/process/<name>/
├── README.md
├── catalog-info.yaml
├── go.mod
├── Dockerfile.dev
├── Dockerfile.main
├── bpmn/
│   ├── process.bpmn
│   ├── policies.yaml
│   └── compile.lock.json
├── cmd/
│   ├── worker/
│   │   └── main.go
│   └── ingress/
│       └── main.go
└── internal/
    ├── workflows/
    │   ├── workflow.go                     # human-owned: glue + TODO hooks
    │   └── workflow_gen.go                 # generated: compiled state machine
    ├── activities/
    │   ├── activities.go                   # human-owned: implementations
    │   └── activities_gen.go               # generated: interfaces + registration
    ├── ingress/
    │   ├── router.go                       # human-owned: bus client wiring
    │   └── router_gen.go                   # generated: message filter + dispatch
    ├── process/
    │   └── state.go                        # human-owned: state helpers
    └── tests/                              # optional (enabled by --include-test-harness)
```

### 2.1 Generated file ownership rule

The compiler **MUST** write and overwrite only files that end with `_gen.go` and `bpmn/compile.lock.json`.

The compiler **MUST NOT** modify any other file.

---

## 3. CLI behavior contract

### 3.1 Scaffold command

The CLI **MUST** support this command, with exactly these flags:

```bash
ameide primitive scaffold --kind process --name <name> --include-gitops --include-test-harness
```

This command **MUST** generate the directory structure in §2 and the initial `bpmn/process.bpmn` template file, `bpmn/policies.yaml`, and a runnable `cmd/worker` + `cmd/ingress`.

### 3.2 Compile command

There is **no** standalone compile command in v1.

Instead, compilation is an internal step invoked by:

* `ameide primitive scaffold --kind process ...` (writes generated outputs), and
* `ameide primitive verify --kind process ...` (compares generated outputs; no writes).

The compiler behavior is:

* Reads BPMN from: `bpmn/process.bpmn`
* Reads policies from: `bpmn/policies.yaml`
* Runs lint (strict)
* Builds IR
* Generates all `_gen.go` files
* Writes `bpmn/compile.lock.json` **deterministically** (no timestamps or non-deterministic fields)

### 3.3 Verify command

The CLI **MUST** support:

```bash
ameide primitive verify --kind process --name <name>
```

Behavior:

* Compiles to memory and compares against committed `_gen.go` files and `bpmn/compile.lock.json` (no writes).
* Fails if any generated artifact differs.

Exit status:

* `0` when repository is up to date.
* `1` when repository is out of date or invalid.

---

## 4. Supported BPMN subset (compileable language)

The compiler supports exactly one BPMN file per Process primitive: `bpmn/process.bpmn`.

### 4.1 BPMN document requirements

`bpmn/process.bpmn` MUST satisfy:

1. The root element is `bpmn:definitions`.
2. `xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL"` MUST be present.
3. `xmlns:ameide="https://ameide.io/schema/bpmn/extensions/v1"` MUST be present.
4. Exactly **one** `bpmn:process` MUST exist under `bpmn:definitions`.
5. That `bpmn:process` MUST have `isExecutable="true"`.
6. BPMN DI elements (`bpmndi:*`, `dc:*`, `di:*`) are allowed and are ignored by compilation and by definition digest calculation.

### 4.2 Supported BPMN element types

Only these BPMN element types participate in compilation:

* `bpmn:process`
* `bpmn:subProcess` (embedded, expanded, inlined; see §4.6)
* `bpmn:startEvent`
* `bpmn:endEvent`
* `bpmn:sequenceFlow`
* `bpmn:serviceTask`
* `bpmn:sendTask`
* `bpmn:userTask`
* `bpmn:receiveTask`
* `bpmn:intermediateCatchEvent` **with exactly one** `bpmn:messageEventDefinition` OR `bpmn:timerEventDefinition`
* `bpmn:intermediateThrowEvent`
* `bpmn:exclusiveGateway`
* `bpmn:inclusiveGateway`
* `bpmn:parallelGateway`
* `bpmn:eventBasedGateway`
* `bpmn:complexGateway`
* `bpmn:message`

Every other BPMN element type is FORBIDDEN and MUST cause a compile error.

### 4.3 Graph structure constraints

The graph MUST satisfy:

* Exactly one start node (the single process-level `bpmn:startEvent`).
* Exactly one end node (the single process-level `bpmn:endEvent`).
* Every node is reachable from the start node.

Cycles are allowed. If you model loops, emitted progress facts MUST use `step_instance_id` to disambiguate runtime occurrences.

### 4.4 Sequence flow constraints

For each `bpmn:sequenceFlow`:

* `id`, `sourceRef`, and `targetRef` MUST exist.
* `sourceRef` and `targetRef` MUST reference elements inside the same `bpmn:process` scope after inlining.

For each node type:

* `bpmn:startEvent` MUST have at least 1 outgoing sequenceFlow.
* `bpmn:endEvent` MUST have at least 1 incoming sequenceFlow.
* `bpmn:serviceTask`, `bpmn:sendTask`, `bpmn:userTask`, `bpmn:receiveTask`, `bpmn:intermediateCatchEvent`, `bpmn:intermediateThrowEvent`, `bpmn:subProcess` MUST have at least 1 incoming sequenceFlow.
* `bpmn:*Gateway` MUST have at least 1 incoming and at least 1 outgoing sequenceFlow.

Multiple outgoing sequence flows are allowed. Outgoing flow evaluation MUST be deterministic and MUST preserve BPMN document order.

### 4.5 Wait nodes (message and timer)

A wait is expressed only by:

* `bpmn:receiveTask` that references a `bpmn:message`, OR
* `bpmn:intermediateCatchEvent` containing exactly one `bpmn:messageEventDefinition messageRef="..."`, OR
* `bpmn:intermediateCatchEvent` containing exactly one `bpmn:timerEventDefinition` with `bpmn:timeDuration`.

Timer constraints:

* `timeDuration` is the only supported timer shape (no `timeDate` / `timeCycle`).

Any other wait shape is FORBIDDEN.

### 4.6 Subprocess compilation (inline semantics)

Each `bpmn:subProcess` is treated as an embedded subprocess:

* The subprocess MUST contain exactly one direct `bpmn:startEvent` and at least one direct `bpmn:endEvent`.
* The subprocess direct start event MUST be a none start event (no event definitions).
* Runtime semantics are equivalent to implicit enter/leave:
  * entering the subprocess schedules its internal start event,
  * reaching a direct end event inside the subprocess leaves the subprocess and resumes outgoing flow from the subprocess container.

---

## 5. Ameide namespace, placement, and XML shapes

### 5.1 Namespace

* Namespace URI: `https://ameide.io/schema/bpmn/extensions/v1`
* Prefix: `ameide`

### 5.2 Placement rule

Every Ameide element MUST appear under `bpmn:extensionElements`.

Any Ameide element outside `bpmn:extensionElements` is FORBIDDEN.

---

## 6. Normalized inbound envelope (runtime signal payload)

All inbound messages delivered to workflows MUST be carried as a single normalized envelope type:

### 6.1 Envelope fields (required)

The envelope is a JSON/proto-serializable structure with these fields:

| Field name        | Type   | Meaning                                          |
| ----------------- | ------ | ------------------------------------------------ |
| `workflow_id`     | string | Temporal WorkflowID target                       |
| `message_name`    | string | Logical message name (matches BPMN message name) |
| `message_id`      | string | Unique delivery id for dedupe                    |
| `correlation_key` | string | Correlation key for subscription matching        |
| `tenant_id`       | string | Tenant scope                                     |
| `correlation_id`  | string | Trace correlation id                             |
| `causation_id`    | string | Causation id                                     |
| `traceparent`     | string | W3C traceparent                                  |
| `payload_bytes`   | bytes  | Opaque payload (process-specific decode)         |

### 6.2 Canonical field names

The exact snake_case names above are mandatory in serialization form.

### 6.3 Routing rule

Ingress MUST call Temporal `SignalWithStart` targeting `workflow_id`.

Ingress MUST use workflow type from `ameide:workflowDefinition.workflowType`.

Ingress MUST send the envelope as the payload of a single signal name:

* Signal name: `ameide.envelope.v1`

### 6.4 Correlation and dedupe binding

Inbound correlation key is ALWAYS read from the normalized envelope field:

* `correlation_key`

Inbound dedupe id is ALWAYS read from:

* `message_id`

There is no per-subscription configuration for where correlation key is extracted.

---

## 7. Template grammar v1

Templates are used in Ameide attributes that end with `Template`.

### 7.1 Syntax

A template is a UTF-8 string containing zero or more placeholders of the form:

* `${<variable>}`

Backslash escaping is supported:

* `\${` is treated as literal `${`.

Any other escape handling is FORBIDDEN.

### 7.2 Variables (workflow context)

Templates evaluated inside workflow execution (task idempotency keys, wait correlation keys) support these variables:

* `${process_instance_id}` → Temporal WorkflowID
* `${process_run_id}` → Temporal RunID
* `${step_id}` → BPMN element id of the currently executing step
* `${step_instance_id}` → deterministic runtime instance id (see §12.3)
* `${state.<path>}` → read from workflow state at `<path>`

### 7.3 Evaluation failure

During compilation:

* Any placeholder that is not one of the variables above is a compile error.
* Any `${state.<path>}` whose `<path>` fails Path grammar is a compile error.

During runtime:

* Any `${state.<path>}` that resolves to missing causes deterministic workflow failure with error name: `AmeideTemplateMissingPath`.
* Any evaluated template producing an empty string causes deterministic workflow failure with error name: `AmeideTemplateEmpty`.

---

## 8. Path grammar v1

### 8.1 Grammar

A path is a dot-separated sequence of identifiers:

* identifier: `[A-Za-z_][A-Za-z0-9_]*`
* path: `identifier("."identifier)*`

Array indexing is FORBIDDEN.

### 8.2 State roots

Paths used in this specification are rooted into one of these root objects:

* `state` (workflow state)
* `request` (activity request object constructed for a task)
* `result` (activity result object returned by an activity)

Root selection is fixed per attribute type:

* `ameide:subscription.correlationKeyTemplate` MUST use only `${state.<path>}`.
* `ameide:taskDefinition.idempotencyKeyTemplate` MUST use only `${state.<path>}` plus workflow variables.
* `ameide:ioMapping/input.source` MUST start with `state.`
* `ameide:ioMapping/input.target` MUST start with `request.`
* `ameide:ioMapping/output.source` MUST start with `result.`
* `ameide:ioMapping/output.target` MUST start with `state.`
* `ameide:subscription.messageIdPath` MUST equal `message_id` exactly.

Any violation is a compile error.

---

## 9. Ameide extension elements (required everywhere)

### 9.1 Process-level `ameide:workflowDefinition`

Placement: `bpmn:process/bpmn:extensionElements`

This element MUST exist exactly once.

Attributes:

* `definitionId` REQUIRED
* `workflowType` REQUIRED
* `workflowIdTemplate` REQUIRED

Constraints:

* `workflowType` MUST equal the BPMN process id (`bpmn:process@id`).
* `workflowIdTemplate` MUST be a deterministic template (no general expression language) and MUST NOT depend on mutable runtime configuration.

### 9.2 Work binding `ameide:taskDefinition`

Placement: on every `bpmn:serviceTask` and every `bpmn:sendTask` under `bpmn:extensionElements`.

This element MUST exist exactly once per task.

Attributes:

* `type` REQUIRED (string, non-empty)
* `idempotencyKeyTemplate` OPTIONAL (compiler MAY provide a deterministic default)
* `policyRef` REQUIRED

Idempotency template constraints:

* If `idempotencyKeyTemplate` is specified, it SHOULD include `${process_instance_id}` and `${step_id}`.
* `idempotencyKeyTemplate` MUST NOT include any placeholder other than those allowed in §7.2.

### 9.3 Static metadata `ameide:taskHeaders`

Placement: on every `bpmn:serviceTask` and `bpmn:sendTask`.

This element MUST exist exactly once per task and may contain zero headers.

Child element:

* `ameide:header` with attributes:

  * `key` REQUIRED, regex: `[a-z0-9][a-z0-9_.-]{0,63}`
  * `value` REQUIRED, non-empty

### 9.4 Deterministic IO mapping `ameide:ioMapping`

Placement: on every `bpmn:serviceTask` and `bpmn:sendTask`.

This element MUST exist exactly once per task.

Children are evaluated strictly in document order:

* `ameide:input source="..." target="..."`
* `ameide:output source="..." target="..."`

Both attributes are REQUIRED and MUST satisfy §8.2 root rules.

Mapping semantics:

* For each input mapping, read value from workflow state at `source`, then assign to request at `target`.
* For each output mapping, read value from activity result at `source`, then assign to workflow state at `target`.
* If `source` does not exist, the compiler-generated code MUST delete the `target` path (unset).

### 9.5 Wait correlation `ameide:subscription`

Placement: on every `bpmn:message/bpmn:extensionElements`.

Each referenced `bpmn:message` MUST contain exactly one `ameide:subscription`.

Attributes:

* `correlationKeyTemplate` REQUIRED
* `messageIdPath` REQUIRED and MUST equal `message_id`

Message name binding:

* The message name used for matching is `bpmn:message@name`.
* `bpmn:message@name` MUST be non-empty.
* All `bpmn:message@name` values MUST be unique within the file.

### 9.6 Human gate binding `ameide:updateDefinition`

Placement: on every `bpmn:userTask/bpmn:extensionElements`.

This element MUST exist exactly once per userTask.

Attributes:

* `name` REQUIRED and MUST equal `Update_<userTaskId>` exactly.

Any other attribute is FORBIDDEN.

---

## 10. Wait node semantics (runtime)

### 10.1 Wait node binding to message

For `bpmn:intermediateCatchEvent`:

* It MUST contain exactly one `bpmn:messageEventDefinition`.
* That definition MUST have `messageRef` referencing a `bpmn:message` id.
* The referenced `bpmn:message` MUST contain an `ameide:subscription`.

For `bpmn:receiveTask`:

* It MUST have attribute `messageRef` referencing a `bpmn:message` id.
* The referenced `bpmn:message` MUST contain an `ameide:subscription`.

### 10.2 Match rule

When a workflow enters a wait node W bound to message M:

* Expected message name = `M.name`
* Expected correlation key = evaluate `subscription.correlationKeyTemplate` in workflow context

An inbound envelope matches W if and only if:

* `envelope.message_name == expected message name`
* `envelope.correlation_key == expected correlation key`

### 10.3 Dedupe rule

For a wait node W:

* The first matching envelope completes the wait.
* After completion, any further envelope with the same `(message_name, correlation_key)` is ignored.

The workflow MUST store the consumed `message_id` for the completed wait in workflow state.

---

## 11. Task completion and explicit waits

* All executable tasks compile to Temporal Activities and complete when the Activity returns.
* If a task needs to orchestrate delegated async work, the workflow MUST model waiting explicitly using BPMN wait nodes (message/timer) compiled to workflow waits (Signals/Updates/Timers). Activities remain bounded “do work” and “check” units.
* BPMN wait nodes (message/timer) are the only supported way to model long waits; workflows MUST NOT block inside Temporal Activities to wait for humans/external parties.

---

## 12. Compiler IR and definitionId

### 12.1 IR v1 contents

The compiler MUST build an IR containing:

* process id
* workflowType
* all nodes with:

  * id, name, BPMN type
  * taskDefinition (for tasks)
  * ioMapping (for tasks)
  * taskHeaders (for tasks)
  * updateDefinition (for user tasks)
  * message binding (for waits)
* all sequenceFlow edges
* all messages with:

  * id, name
  * subscription

### 12.2 Canonical digest algorithm

The compiler MUST compute `definitionId` as:

* `definitionId = "sha256:" + HEX(SHA256(CANONICAL_BYTES(IR)))`

Where `CANONICAL_BYTES(IR)` is produced by this exact procedure:

1. Write line: `IRv1\n`
2. Write line: `process_id=<processId>\n`
3. Write line: `workflow_type=<workflowType>\n`
4. For each message sorted by message id ascending:

   * `message|<id>|<name>|<correlationKeyTemplate>|message_id\n`
5. For each node sorted by node id ascending:

   * If node is task:

     * `task|<id>|<bpmnType>|<type>|<policyRef>|<idempotencyKeyTemplate>\n`
     * For each header in document order: `header|<id>|<key>|<value>\n`
     * For each ioMapping entry in document order:

       * `in|<id>|<source>|<target>\n` or `out|<id>|<source>|<target>\n`
   * If node is wait:

     * For message wait: `wait|<id>|<bpmnType>|message|<messageId>|<messageName>|<correlationKeyTemplate>\n`
     * For timer wait: `wait|<id>|<bpmnType>|timer|<timerDurationSeconds>\n`
   * If node is userTask:

     * `user|<id>|<bpmnType>|<updateName>\n`
   * If node is start/end:

     * `event|<id>|<bpmnType>\n`
6. For each sequenceFlow in BPMN document order:

   * `flow|<id>|<sourceRef>|<targetRef>\n`

### 12.3 Step instance id

The runtime step instance id MUST be:

* `<step_id>/1`

Because the compiled graph is acyclic and each step executes at most once per workflow execution.

---

## 13. Generated Go code requirements

### 13.1 Packages

Generated files MUST be in these packages:

* `internal/workflows/*_gen.go` uses package `workflows`
* `internal/activities/*_gen.go` uses package `activities`
* `internal/ingress/*_gen.go` uses package `ingress`
* `internal/process/*_gen.go` uses package `process`

### 13.2 Worker registration

`cmd/worker/main.go` MUST:

* create a Temporal worker with:

  * Task queue name from environment variable `TEMPORAL_TASK_QUEUE`
  * Namespace from environment variable `TEMPORAL_NAMESPACE`
* register the generated workflow function:

  * name = `workflowType` (string)
* register generated activity function stubs:

  * each activity registered name = `taskDefinition.type`

### 13.3 Workflow function signature

The generated workflow MUST have signature:

```go
func ProcessWorkflow(ctx workflow.Context, input process.WorkflowInput) error
```

Where:

```go
type WorkflowInput struct {
    ProcessDefinitionID string
}
```

The workflow MUST validate:

* `input.ProcessDefinitionID == ameide:workflowDefinition.definitionId`

If mismatch, workflow MUST fail deterministically with error name: `AmeideDefinitionMismatch`.

### 13.4 Signal handling

The workflow MUST:

* receive inbound envelopes on signal name `ameide.envelope.v1`
* append envelopes into a deterministic in-memory buffer stored in workflow state

Buffer retention rule:

* The buffer MUST retain all unmatched envelopes until consumed by a wait node.
* When an envelope is consumed by a wait node, it MUST be removed from buffer.

### 13.5 Activity invocation

For each task node:

* Build `request` as `map[string]any`.
* Apply input ioMapping in order.
* Compute idempotency key via template.
* Load ActivityOptions from the resolved policyRef.
* Execute Temporal Activity registered under `taskDefinition.type`.
* Decode activity result into `map[string]any` named `result`.
* Apply output ioMapping in order.
* Advance to next node.

### 13.6 User task update

For each userTask node:

* Register update handler named `Update_<userTaskId>`.
* The update handler input type MUST be:

```go
type UserTaskUpdate struct {
    OutgoingFlowID string
}
```

Semantics:

* The update MUST validate `OutgoingFlowID` is one of the userTask’s outgoing sequenceFlow ids.
* The workflow MUST set the next node as the targetRef of the selected sequenceFlow.

If validation fails, the update MUST return error and MUST NOT advance the workflow.

---

## 14. Policies catalog

### 14.1 Location

The policy catalog MUST be a YAML file at:

* `bpmn/policies.yaml`

### 14.2 Schema (required fields)

The YAML MUST contain:

```yaml
version: 1
policies:
  - name: <policyRef>
    schedule_to_close_timeout_seconds: <int>
    start_to_close_timeout_seconds: <int>
    retry:
      maximum_attempts: <int>
      initial_interval_seconds: <int>
      maximum_interval_seconds: <int>
      backoff_coefficient: <float>
      non_retryable_error_types:
        - <string>
        - ...
```

Constraints:

* `version` MUST equal `1`.
* Every integer timeout MUST be > 0.
* `maximum_attempts` MUST be >= 1.
* `backoff_coefficient` MUST be >= 1.0.
* `name` values MUST be unique.

### 14.3 Resolution

For every `ameide:taskDefinition.policyRef` referenced in BPMN:

* An exact matching policy name MUST exist in the catalog.
* The compiler MUST emit resolved values into generated Go code as constants.

---

## 15. Ingress runtime requirements

`cmd/ingress/main.go` MUST:

* read from a bus consumer (implementation is human-owned in `internal/ingress/router.go`)
* for each inbound envelope:

  * validate all required envelope fields are non-empty
  * call Temporal `SignalWithStart`:

    * WorkflowID = `envelope.workflow_id`
    * WorkflowType = `workflowType`
    * SignalName = `ameide.envelope.v1`
    * SignalArg = the envelope
    * WorkflowIDReusePolicy = `AllowDuplicateFailedOnly`
    * WorkflowIDConflictPolicy = `UseExisting`

On validation failure of an envelope, ingress MUST terminate the process with non-zero exit code.

---

## 16. Required tests

The scaffold MUST include tests that compile and run under `go test ./...`.

### 16.1 Compile determinism test

`internal/tests/compile_test.go` MUST:

* run the compiler in-memory on `bpmn/process.bpmn`
* compare the produced `_gen.go` and `compile.lock.json` bytes to repository files
* fail if any mismatch exists

### 16.2 Workflow skeleton execution test

`internal/tests/<name>_workflow_test.go` MUST:

* start Temporal test environment
* register generated workflow and stub activities
* send an envelope that drives the workflow through the entire BPMN path:

  * for each wait node, send a matching envelope with correct `(message_name, correlation_key)`
* assert workflow completes successfully

The test MUST fail if any human-owned TODO remains unimplemented in a way that blocks compilation.

---

## 17. Complete XSD (namespace elements only)

The Ameide XSD MUST be exactly this (file path: `bpmn/ameide-bpmn-v1.xsd` inside the CLI repo, embedded in the binary for validation):

```xml
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  targetNamespace="https://ameide.io/schema/bpmn/extensions/v1"
  xmlns:ameide="https://ameide.io/schema/bpmn/extensions/v1"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified">

  <xs:simpleType name="path">
    <xs:restriction base="xs:string">
      <xs:pattern value="[A-Za-z_][A-Za-z0-9_]*(\.[A-Za-z_][A-Za-z0-9_]*)*"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:element name="workflowDefinition" type="ameide:workflowDefinitionType"/>
  <xs:complexType name="workflowDefinitionType">
    <xs:attribute name="definitionId" type="xs:string" use="required"/>
    <xs:attribute name="workflowType" type="xs:string" use="required"/>
    <xs:attribute name="workflowIdTemplate" type="xs:string" use="required"/>
  </xs:complexType>

  <xs:element name="taskDefinition" type="ameide:taskDefinitionType"/>
  <xs:complexType name="taskDefinitionType">
    <xs:attribute name="type" type="xs:string" use="required"/>
    <xs:attribute name="idempotencyKeyTemplate" type="xs:string" use="optional"/>
    <xs:attribute name="policyRef" type="xs:string" use="required"/>
  </xs:complexType>

  <xs:element name="taskHeaders" type="ameide:taskHeadersType"/>
  <xs:complexType name="taskHeadersType">
    <xs:sequence>
      <xs:element name="header" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:attribute name="key" type="xs:string" use="required"/>
          <xs:attribute name="value" type="xs:string" use="required"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:element name="ioMapping" type="ameide:ioMappingType"/>
  <xs:complexType name="ioMappingType">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="input" type="ameide:mappingEntryType"/>
      <xs:element name="output" type="ameide:mappingEntryType"/>
    </xs:choice>
  </xs:complexType>

  <xs:complexType name="mappingEntryType">
    <xs:attribute name="source" type="ameide:path" use="required"/>
    <xs:attribute name="target" type="ameide:path" use="required"/>
  </xs:complexType>

  <xs:element name="subscription" type="ameide:subscriptionType"/>
  <xs:complexType name="subscriptionType">
    <xs:attribute name="correlationKeyTemplate" type="xs:string" use="required"/>
    <xs:attribute name="messageIdPath" type="xs:string" use="required"/>
  </xs:complexType>

  <xs:element name="updateDefinition" type="ameide:updateDefinitionType"/>
  <xs:complexType name="updateDefinitionType">
    <xs:attribute name="name" type="xs:string" use="required"/>
  </xs:complexType>

</xs:schema>
```

---

## 18. Summary of closed decisions

This v1 spec fixes all prior ambiguities by hard requirements:

* correlation extraction: always `envelope.correlation_key`
* dedupe id extraction: always `envelope.message_id`
* waits: only `receiveTask` and `intermediateCatchEvent(message)`
* subscriptions: only on `bpmn:message`
* process identity: definition digest from IR canonical bytes; pinned in BPMN
* workflow routing: always `envelope.workflow_id`
* workflow type: always BPMN process id
* user tasks: always Updates named `Update_<userTaskId>`
* policies: always from `bpmn/policies.yaml` with fully specified fields
* compiler outputs: only `_gen.go` files and `compile.lock.json`

If you want, I can convert this exact spec into:

* a single `SPEC.md` file to live beside the generator code, and
* a checklist test plan mapping each MUST to a unit/integration test, so the implementation stays locked to the contract.
