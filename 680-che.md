---
title: "680 – Eclipse Che provider for agentic coding (human workspaces + automation tasks)"
status: draft
owners:
  - platform-devx
  - platform
  - gitops
created: 2026-01-15
suite: "agentic-coding"
source_of_truth: false
---

# 680 – Eclipse Che provider for agentic coding (human workspaces + automation tasks)

## 0) Purpose

Add **Eclipse Che** as a first-class **workspace/task provider** in Ameide’s agentic coding model, while keeping a single set of platform contracts.

This backlog assumes:

- **Two-provider strategy:** Che and Coder are both supported providers for **human workspaces** and **automation tasks**.
- **No adapters / no forked contracts:** Che must speak the same platform contracts for **events/protos**, **CLI front doors + evidence**, and **Codex credential model**.
- **Camunda orchestration is OK:** Camunda supervises run lifecycle; the provider executes the run.

Che-native primitives we intentionally leverage:

- **Workspace = `DevWorkspace` CR** (create/start/stop/delete via Kubernetes APIs).
- **VS Code (web) tasks = Devfile commands**.
- Devfile lifecycle events exist; **`postStart` may only reference `exec` commands**.

Normative references (do not fork):

- Model + terminology: `backlog/650-agentic-coding-overview.md`
- Big picture map (Coder + Che): `backlog/690-agentic-dev-environments-coder-che.md`
- Orchestration + “task” semantics: `backlog/651-agentic-coding-ameide-coding-agent.md`
- Human workspace UX + guardrails: `backlog/652-agentic-coding-dev-workspace.md`
- Testing layers: `backlog/653-agentic-coding-test-automation.md`
- CLI front doors + evidence layout: `backlog/654-agentic-coding-cli-surface.md`
- Codex auth materialization: `backlog/613-codex-auth-json-secret.md`
- Codex session broker (clean target state): `backlog/675-codex-broker.md`
- Codex auth refresh (rotating secrets): `backlog/675-codex-refresher.md`
- Codex depletion monitoring + slot selection: `backlog/675-codex-monitor.md`
- Codex CLI pinning policy: `backlog/433-codex-cli-057.md`

## 1) Scope

### 1.1 In scope

- Che as a provider for:
  - **Workspace mode** (interactive, long-lived, human-in-the-loop).
  - **Task mode** (ephemeral, automation-driven, run-to-completion with TTL/cleanup).
- Keycloak OIDC integration for Che.
- DevWorkspace templates that expose standard “agent-native” tasks in VS Code web.
- Running platform verification front doors inside Che environments (`ameide test`, `ameide test e2e`) and emitting evidence in the standard layout.
- Using the platform’s Codex credential distribution + slot model inside Che workspaces/tasks.

### 1.2 Out of scope

- Creating Che-specific topics/schemas for “requirements released” or “agent run requested”.
- Building a Che-only “adapter service” that translates between platform messages and Che messages.
- Replacing Coder; this is a complementary provider.

## 2) Decisions (alignment constraints)

### 2.1 One contract, two providers

Provider choice is a runtime decision; the contracts remain provider-independent:

- **Inputs:** repo coordinates + ref + agent profile + run intent + context payload (platform proto).
- **Execution:** a single deterministic entrypoint command in a controlled workspace environment.
- **Outputs:** evidence bundle + status timeline + optional PR URL.

### 2.2 Camunda supervises; provider executes

Camunda owns:

- idempotency/retries/concurrency limits
- timeouts + cleanup requirements
- evidence requirements and gating
- optional human gates

Che (like Coder) is an execution plane.

### 2.3 Argo CD owns deployed-state reconciliation (preview truth)

Process/orchestration may cause Git changes (e.g., PRs that update deployable artifacts or GitOps inputs). **Argo CD** remains the mechanism that reconciles deployed state back to Git and provides the “deployed truth” signal used by Phase 3 E2E (`ameide test e2e`) per `backlog/653-agentic-coding-test-automation.md`.

### 2.4 CLI front doors are mandatory (no bespoke scripts as “truth”)

Inside Che, the verification and evidence-producing commands are:

- `ameide test` (Phase 0/1/2; no Telepresence; emits JUnit)
- `ameide test e2e` (Phase 3; deployed truth; Playwright against target URL)

Any provider-specific wrapper script must be glue only (log routing, env wiring), not a second verification system.

### 2.5 Codex operational model is mandatory

Che workspaces/tasks must follow the same Codex operational model:

- Codex CLI is **pinned** per `backlog/433-codex-cli-057.md` (avoid “install latest” drift).
- Codex auth is file-based `auth.json` managed by secrets pipeline (`backlog/613-codex-auth-json-secret.md`).
- Clean target state is lease-based `codex-broker` session allocation (no shared `auth.json` across concurrent consumers), per `backlog/675-codex-broker.md`.
- Automated consumers mount **rotating** secrets (`codex-auth-rotating-N`) (`backlog/675-codex-refresher.md`).
- Runs are depletion-aware using `codex-account-status-N` (`backlog/675-codex-monitor.md`).

## 3) Identity model

### 3.1 Humans (workspace mode)

- Human uses Che via Keycloak OIDC.
- Workspace is owned/visible in Che UX.
- Human can open VS Code web at any time, inspect evidence, intervene, rerun tasks.

### 3.2 Automation (task mode)

- Automation run uses a platform-controlled identity (service account / orchestrator identity), not a human browser session.
- Git writes for automation use a bot identity (GitHub App installation token) consistent with `backlog/651-agentic-coding-ameide-coding-agent.md`.
- RBAC/network policy must be profile-scoped (code/gitops/sre) and least-privilege.

#### 3.2.1 RBAC bootstrap for cluster-touching tasks (bind-only)

If a Che task is allowed to interact with cluster resources (example: reading the environment config/secret inputs for `ameide test e2e`, or managing Gateway API routing primitives for an in-cluster test harness), the platform must follow the same vendor-aligned pattern as the Coder provider:

- Predeclare the exact permission sets centrally (ClusterRoles/Roles).
- Grant the task launcher identity only `bind` on those specific roles (restricted via `resourceNames`) plus the ability to create the corresponding RoleBindings in the target namespaces.
- Do not let workspace/task provisioning author arbitrary Roles with new privileges (avoids RBAC privilege-escalation failures and keeps “routing power” auditable).

### 3.3 Mapping platform users → Che namespaces

Che exposes a stable endpoint for discovering a user’s namespace:

- `https://<che_fqdn>/api/kubernetes/namespace`

Platform should store the returned namespace in the platform user record (`cheNamespace`) so provisioning is deterministic.

## 4) Environment contract (shared across Che + Coder)

To avoid “two providers = two dev machines”, we adopt one authoritative contract and generate provider-native artifacts from it:

- Authoritative contract: `.devcontainer/coder/devcontainer.json` (per `backlog/650-agentic-coding-overview.md`).
- Build a digest-pinned workspace image derived from that contract.
- Use the same pinned image digest in:
  - Che `DevWorkspace` container component(s)
  - Coder templates (envbuilder path)

## 5) Execution model in Che

### 5.1 Workspace = `DevWorkspace` CR

- Workspace lifecycle is controlled via `DevWorkspace` CRUD and `spec.started`.

### 5.1.1 Environment hostname convention

Che “front door” hostnames MUST be environment-scoped:

- `dev`: `che.dev.ameide.io`
- `staging`: `che.staging.ameide.io`
- `production`: `che.ameide.io` (preferred) or `che.prod.ameide.io` if we intentionally keep an explicit env label

### 5.1.1.1 Che instance cardinality (per cluster)

Che supports deploying only one Che instance per Kubernetes cluster. For a single AKS cluster hosting multiple environments (dev/staging/prod namespaces), we MUST treat Che as a single shared control-plane component and enable it in exactly one environment (typically `dev`) unless/until we adopt a cluster-per-env strategy.

### 5.1.1.2 Kubernetes API authentication requirement (native vs vCluster)

Che’s gateway enforces authorization using Kubernetes RBAC. This requires that the Kubernetes API server (or an equivalent delegated authn/authz path) can validate the OIDC identity token Che forwards for the user.

Provider implementations MUST explicitly pick and document one of these vendor-aligned approaches:

- **Native control plane OIDC (preferred when feasible):** configure the managed Kubernetes control plane to accept the external OIDC issuer (Keycloak), subject to provider constraints (issuer reachability, certificate trust, audience/claims) and org policy.
- **Che-in-vCluster (fallback / portability):** run Che on a virtual Kubernetes cluster whose API server is configured with the external OIDC issuer, avoiding host control-plane changes.

The provider MUST record which token type is forwarded (`id_token` vs `access_token`) and ensure the Kubernetes API server is configured to accept it (audiences/claims).

#### 5.1.1.2.1 Stable username claim (avoid RBAC subject mismatches)

Che auto-provisions per-user namespaces and RBAC bindings based on a **username string** derived from OIDC claims. Kubernetes RBAC decisions are also based on the **username string** produced by the API server’s OIDC authentication.

To avoid the “login succeeds but everything is `403 Forbidden`” failure mode, the provider MUST:

- Standardize on a **stable, unique** OIDC claim for the Kubernetes username (vendor examples use `email`).
- Configure both:
  - Kubernetes (host control plane or vCluster API server): `--oidc-username-claim=email`
  - Che server: `CHE_OIDC_USERNAME__CLAIM=email`
- Ensure Kubernetes does not unexpectedly prefix the resolved username (set `--oidc-username-prefix=-` when using claims like `email`).

Symptom:

- Che dashboard errors like:
  - `devworkspaces.workspace.devfile.io is forbidden: User "..." cannot list ... in the namespace "..."`
  - `secrets "user-profile" is forbidden: User "..." cannot get ... in the namespace "..."`

Diagnosis (read-only):

- Check whether the `RoleBinding` subjects in the user namespace bind to the same username Kubernetes is authenticating:
  - `kubectl -n <user-namespace> get rolebinding -o yaml | rg -n 'kind: User|name:'`
  - `kubectl auth can-i list devworkspaces.workspace.devfile.io -n <user-namespace> --as='<username>'`

If the RoleBindings bind to one identity (e.g. display name) but Kubernetes authenticates as another (e.g. email), fix the claim mapping and re-login so Che can provision RBAC for the canonical identity.

#### 5.1.1.2.1.1 Known sharp edge: oauth2-proxy CSRF cookie mismatch (multi-app domains)

Che’s gateway uses `oauth2-proxy` and sets CSRF cookies during the auth flow. When multiple oauth2-proxy-backed apps share a cookie domain (common on `*.dev.ameide.io`), cookie name collisions can cause:

- `403 Forbidden`
- “Login Failed: Unable to find a valid CSRF token”

Mitigations (provider MUST pick one and document it):

1. **Isolate cookie names per app** (recommended): set `OAUTH2_PROXY_COOKIE_NAME` for Che’s gateway oauth2-proxy so it does not share `_oauth2_proxy*` cookie names with other apps.
2. **Operational recovery**: clear site data/cookies for `che.dev.ameide.io` (and often `auth.dev.ameide.io`), or re-try in an incognito window after changes.

#### 5.1.1.2.1.2 Known sharp edge: scale-from-zero vs DevWorkspace progress timeout

If the `workspaces-che` node pool is configured to autoscale from `0`, DevWorkspace workloads may not schedule immediately. If the DevWorkspace operator `workspace.progressTimeout` is too low, a workspace can be marked Failed before nodes scale up.

Mitigation:

- Increase `DevWorkspaceOperatorConfig/devworkspace-config` (`namespace: eclipse-che`) `config.workspace.progressTimeout` (e.g. `10–15m`) for the Che deployment, and ensure workspace templates use the expected nodeSelector/tolerations for `ameide.io/pool=workspaces-che` (see `backlog/684-aks-node-pool-strategy-option-b.md`).

#### 5.1.1.2.2 Deterministic namespace provisioning (vendor-supported)

Changing the Kubernetes username claim (or Che’s `CHE_OIDC_USERNAME__CLAIM`) changes the resolved username key and can cause Che to create a **new** user namespace and RBAC bindings.

If we need stable, deterministic namespaces (recommended for automation and for avoiding “stale session → wrong namespace” confusion), the provider SHOULD use the vendor-supported pattern:

- Disable auto-provisioning: `CheCluster.spec.devEnvironments.defaultNamespace.autoProvision: false`
- Pre-provision user namespaces in advance and annotate them with `che.eclipse.org/username: <canonical-username>`

Namespace templates MUST include `<username>` or `<userid>`, and the resolved username is sanitized for namespace naming (invalid characters become `-`). Treat this as part of the stable identity contract.

Operational note: “log out/in” or an incognito window can help refresh the UI session, but stable namespace provisioning is the supported way to remove ambiguity.

### 5.1.2 Routing model note (Ingress vs Gateway API)

Upstream Che Kubernetes installs typically assume an **Ingress controller** is present and that exposing workspace/public endpoints by creating Kubernetes `Ingress` objects is supported.

If a cluster uses Gateway API (e.g. Envoy Gateway) as the primary ingress plane, treating `Service/che-gateway` as the single “front door” is a deliberate deviation. The provider MUST:

- Explicitly document the supported routing strategy (single-host vs multi-host), and
- Validate that both the Che UI and any required workspace/public endpoints are reachable under that strategy (or explicitly mark endpoints as out of scope for that increment).

### 5.2 Devfile commands as “agent-native UX”

Each DevWorkspace template must expose these Tasks (Devfile `exec` commands):

- `Agent: Run` (runs the deterministic entrypoint; writes evidence).
- `Agent: Tail logs` (tails the standard evidence log path).
- `Agent: Stop` (best-effort cancellation signal; marks run aborted).

### 5.3 Auto-run (`postStart`) is allowed only when safe

If `postStart` is used:

- It must reference an `exec` command (Devfile rule).
- The entrypoint must be idempotent (do not re-run if run already `running|done|failed`).
- `postStart` is for task mode only (automation intent), not a default for human workspaces.

### 5.4 Editor attachment when provisioning via Kubernetes APIs

When creating `DevWorkspace` resources via Kubernetes APIs (instead of via the Che dashboard UX), the provider MUST ensure the IDE is attached deterministically, either by:

- Explicitly including `spec.contributions` that references the VS Code (Open Source) editor devfile, or
- Explicitly documenting and validating that the Che cluster default editor is applied to CR-created workspaces.

If we do neither, workspaces can be created successfully but not present the expected “open VS Code web” UX.

### 5.5 Cleanup semantics (stop vs delete)

- **Stop** is done by patching `spec.started=false` (workload stops, resources may remain).
- **Delete** is done by deleting the `DevWorkspace` CR (workload stops and workspace-scoped resources are reclaimed per Che operator behavior).

Task mode (ephemeral automation) MUST delete the `DevWorkspace` CR as its cleanup mechanism, unless the run is explicitly retained for debugging (stop first, then delete after a retention window).

### 5.6 Namespace provisioning prerequisite

When an admin or automation creates a `DevWorkspace` for a human user, the target user namespace MUST already exist (either the user has logged into Che at least once, or the platform has pre-provisioned the Che user namespace).

### 5.7 Naming and validation constraints

- `DevWorkspace.metadata.name` MUST be DNS-label-safe (lowercase, <=63 chars) and follow Devfile validation constraints.
- Devfile command IDs and related identifiers MUST satisfy Devfile validation rules (treat them as a contract, not “best effort”).

## 6) Task/workspace entrypoint contract (provider-independent)

Che and Coder must both run the same “task entrypoint” defined by the platform (see `backlog/651-agentic-coding-ameide-coding-agent.md`).

Minimum in-workspace flow:

1. Checkout repo at the requested ref.
2. Apply patch (Codex-assisted and/or deterministic tooling).
3. Run `ameide test` (Phase 0/1/2).
4. Push branch + open PR (automation) or leave for human (workspace mode).
5. Persist evidence + result manifest.

Evidence layout must match `backlog/654-agentic-coding-cli-surface.md`.

## 7) GitHub integration (shared)

Automation PR creation uses GitHub App installation tokens (short-lived):

- Do not mount the GitHub App private key into workspaces.
- Use a platform-shared token-minting mechanism (usable by both Che and Coder) to obtain installation tokens.
- Use installation token for `git push` over HTTPS and PR creation via GitHub API.
- Installation tokens expire after ~1 hour; long-running tasks MUST re-mint a fresh token before `git push` / PR operations as needed.

## 8) Codex integration (shared)

Che task/workspace mounts:

- `Secret/codex-auth-rotating-N` (file `auth.json`) as the authentication source.
- `Secret/codex-account-status-N` (file `status.json`) to decide usability/selection.

Selection rule (minimum):

- If a slot is `usable=false` or missing, do not use it.
- If multiple slots are usable, pick the highest `score` (least depleted).

### 8.1 Auth materialization path

Inside the workspace/task container, Codex auth MUST be materialized to the Codex default location (`~/.codex/auth.json`) or Codex must be configured to read the mounted `auth.json` from the platform-defined path.

### 8.2 Non-interactive execution and safety flags (task mode)

Task mode MUST run Codex in non-interactive automation mode (e.g. `codex exec`) and MUST set explicit safety policy (sandbox + approvals) consistent with the platform’s guardrails.

## 9) DevWorkspace skeleton (illustrative)

This is illustrative; exact fields depend on the provider image build + repo checkout conventions.

```yaml
apiVersion: workspace.devfile.io/v1alpha2
kind: DevWorkspace
metadata:
  name: <dns-safe-workspace-name>
  namespace: <che-namespace-or-automation-namespace>
spec:
  routingClass: che
  started: true
  # When creating DevWorkspaces via Kubernetes APIs, ensure the IDE attachment is explicit
  # (unless the Che cluster default editor is guaranteed for CR-created workspaces).
  contributions:
    - name: ide
      uri: http://che-dashboard.<che-namespace>.svc.cluster.local:8080/dashboard/api/editors/devfile?che-editor=che-incubator/che-code/latest
  template:
    projects:
      - name: repo
        git:
          remotes:
            origin: https://github.com/<org>/<repo>.git
          checkoutFrom:
            revision: <ref>
    components:
      - name: tooling
        container:
          image: ghcr.io/ameideio/<workspace-image>@sha256:<digest>
          mountSources: true
          env:
            - name: CHE_DASHBOARD_URL
              value: "https://<che_fqdn>/dashboard/"
            - name: AMEIDE_AGENT_PROFILE
              value: "<code|gitops|sre>"
            - name: AMEIDE_RUN_ID
              value: "<run-id>"
            - name: AMEIDE_RUN_INTENT
              value: "<workspace|task>"
    commands:
      - id: agent-run
        exec:
          label: "Agent: Run"
          component: tooling
          workingDir: ${PROJECT_SOURCE}
          commandLine: "/usr/local/bin/ameide-agent-entrypoint"
      - id: agent-tail
        exec:
          label: "Agent: Tail logs"
          component: tooling
          workingDir: ${PROJECT_SOURCE}
          commandLine: "tail -f artifacts/agent-ci/${AMEIDE_RUN_ID}/run.log || true"
    events:
      postStart:
        - agent-run # only for task mode (automation intent) + idempotent entrypoint
```

## 10) Delivery plan (E2E increments, aligned)

### Increment 0 — Che baseline + SSO

- Che installed + Keycloak OIDC works; human can open VS Code web.

### Increment 1 — Che workspace image parity + CLI front doors

- Workspace image is digest-pinned and derived from the devcontainer contract.
- Running `ameide test` in Che produces evidence in the standard layout.

### Increment 2 — Che “task mode” supervised by Camunda

- Camunda triggers an ephemeral Che run with TTL/cleanup.
- Run produces evidence bundle and a deterministic outcome record.

### Increment 3 — Codex in Che (pinned + rotating auth + depletion-aware)

- Task mounts `codex-auth-rotating-N`, reads `codex-account-status-N`, uses pinned Codex CLI.

### Increment 4 — PR automation end-to-end

- Task pushes branch + opens PR with GitHub App installation token.

### Increment 5 — Provider parity checks (Che + Coder)

- Same run intent succeeds on both providers with identical evidence expectations and guardrails.

## 11) Open questions (to resolve for “both providers, both modes”)

1. **Default namespace for automation tasks:** dedicated automation namespaces (preferred) vs user namespaces.
2. **Profile selection source of truth:** `.ameide/agent-profile` + `AMEIDE_AGENT_PROFILE` precedence.
3. **Cross-provider UX for “open the environment”:** contract is evidence-first; provider URLs are optional convenience fields.
