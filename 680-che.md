---
title: "680 – Eclipse Che provider for agentic coding (human workspaces + automation tasks)"
status: draft
owners:
  - platform-devx
  - platform
  - gitops
created: 2026-01-15
suite: "agentic-coding"
source_of_truth: false
---

# 680 – Eclipse Che provider for agentic coding (human workspaces + automation tasks)

## 0) Purpose

Add **Eclipse Che** as a first-class **workspace/task provider** in Ameide’s agentic coding model, while keeping a single set of platform contracts.

This backlog assumes:

- **Two-provider strategy:** Che and Coder are both supported providers for **human workspaces** and **automation tasks**.
- **No adapters / no forked contracts:** Che must speak the same platform contracts for **events/protos**, **CLI front doors + evidence**, and **Codex credential model**.
- **Camunda orchestration is OK:** Camunda supervises run lifecycle; the provider executes the run.

Che-native primitives we intentionally leverage:

- **Workspace = `DevWorkspace` CR** (create/start/stop/delete via Kubernetes APIs).
- **VS Code (web) tasks = Devfile commands**.
- Devfile lifecycle events exist; **`postStart` may only reference `exec` commands**.

Normative references (do not fork):

- Model + terminology: `backlog/650-agentic-coding-overview.md`
- Orchestration + “task” semantics: `backlog/651-agentic-coding-ameide-coding-agent.md`
- Human workspace UX + guardrails: `backlog/652-agentic-coding-dev-workspace.md`
- Testing layers: `backlog/653-agentic-coding-test-automation.md`
- CLI front doors + evidence layout: `backlog/654-agentic-coding-cli-surface.md`
- Codex auth materialization: `backlog/613-codex-auth-json-secret.md`
- Codex auth refresh (rotating secrets): `backlog/675-codex-refresher.md`
- Codex depletion monitoring + slot selection: `backlog/675-codex-monitor.md`
- Codex CLI pinning policy: `backlog/433-codex-cli-057.md`

## 1) Scope

### 1.1 In scope

- Che as a provider for:
  - **Workspace mode** (interactive, long-lived, human-in-the-loop).
  - **Task mode** (ephemeral, automation-driven, run-to-completion with TTL/cleanup).
- Keycloak OIDC integration for Che.
- DevWorkspace templates that expose standard “agent-native” tasks in VS Code web.
- Running platform verification front doors inside Che environments (`ameide test`, `ameide test e2e`) and emitting evidence in the standard layout.
- Using the platform’s Codex credential distribution + slot model inside Che workspaces/tasks.

### 1.2 Out of scope

- Creating Che-specific topics/schemas for “requirements released” or “agent run requested”.
- Building a Che-only “adapter service” that translates between platform messages and Che messages.
- Replacing Coder; this is a complementary provider.

## 2) Decisions (alignment constraints)

### 2.1 One contract, two providers

Provider choice is a runtime decision; the contracts remain provider-independent:

- **Inputs:** repo coordinates + ref + agent profile + run intent + context payload (platform proto).
- **Execution:** a single deterministic entrypoint command in a controlled workspace environment.
- **Outputs:** evidence bundle + status timeline + optional PR URL.

### 2.2 Camunda supervises; provider executes

Camunda owns:

- idempotency/retries/concurrency limits
- timeouts + cleanup requirements
- evidence requirements and gating
- optional human gates

Che (like Coder) is an execution plane.

### 2.3 Argo CD owns deployed-state reconciliation (preview truth)

Process/orchestration may cause Git changes (e.g., PRs that update deployable artifacts or GitOps inputs). **Argo CD** remains the mechanism that reconciles deployed state back to Git and provides the “deployed truth” signal used by Phase 3 E2E (`ameide test e2e`) per `backlog/653-agentic-coding-test-automation.md`.

### 2.4 CLI front doors are mandatory (no bespoke scripts as “truth”)

Inside Che, the verification and evidence-producing commands are:

- `ameide test` (Phase 0/1/2; no Telepresence; emits JUnit)
- `ameide test e2e` (Phase 3; deployed truth; Playwright against target URL)

Any provider-specific wrapper script must be glue only (log routing, env wiring), not a second verification system.

### 2.5 Codex operational model is mandatory

Che workspaces/tasks must follow the same Codex operational model:

- Codex CLI is **pinned** per `backlog/433-codex-cli-057.md` (avoid “install latest” drift).
- Codex auth is file-based `auth.json` managed by secrets pipeline (`backlog/613-codex-auth-json-secret.md`).
- Automated consumers mount **rotating** secrets (`codex-auth-rotating-N`) (`backlog/675-codex-refresher.md`).
- Runs are depletion-aware using `codex-account-status-N` (`backlog/675-codex-monitor.md`).

## 3) Identity model

### 3.1 Humans (workspace mode)

- Human uses Che via Keycloak OIDC.
- Workspace is owned/visible in Che UX.
- Human can open VS Code web at any time, inspect evidence, intervene, rerun tasks.

### 3.2 Automation (task mode)

- Automation run uses a platform-controlled identity (service account / orchestrator identity), not a human browser session.
- Git writes for automation use a bot identity (GitHub App installation token) consistent with `backlog/651-agentic-coding-ameide-coding-agent.md`.
- RBAC/network policy must be profile-scoped (code/gitops/sre) and least-privilege.

### 3.3 Mapping platform users → Che namespaces

Che exposes a stable endpoint for discovering a user’s namespace:

- `https://<che_fqdn>/api/kubernetes/namespace`

Platform should store the returned namespace in the platform user record (`cheNamespace`) so provisioning is deterministic.

## 4) Environment contract (shared across Che + Coder)

To avoid “two providers = two dev machines”, we adopt one authoritative contract and generate provider-native artifacts from it:

- Authoritative contract: `.devcontainer/coder/devcontainer.json` (per `backlog/650-agentic-coding-overview.md`).
- Build a digest-pinned workspace image derived from that contract.
- Use the same pinned image digest in:
  - Che `DevWorkspace` container component(s)
  - Coder templates (envbuilder path)

## 5) Execution model in Che

### 5.1 Workspace = `DevWorkspace` CR

- Workspace lifecycle is controlled via `DevWorkspace` CRUD and `spec.started`.

### 5.2 Devfile commands as “agent-native UX”

Each DevWorkspace template must expose these Tasks (Devfile `exec` commands):

- `Agent: Run` (runs the deterministic entrypoint; writes evidence).
- `Agent: Tail logs` (tails the standard evidence log path).
- `Agent: Stop` (best-effort cancellation signal; marks run aborted).

### 5.3 Auto-run (`postStart`) is allowed only when safe

If `postStart` is used:

- It must reference an `exec` command (Devfile rule).
- The entrypoint must be idempotent (do not re-run if run already `running|done|failed`).
- `postStart` is for task mode only (automation intent), not a default for human workspaces.

## 6) Task/workspace entrypoint contract (provider-independent)

Che and Coder must both run the same “task entrypoint” defined by the platform (see `backlog/651-agentic-coding-ameide-coding-agent.md`).

Minimum in-workspace flow:

1. Checkout repo at the requested ref.
2. Apply patch (Codex-assisted and/or deterministic tooling).
3. Run `ameide test` (Phase 0/1/2).
4. Push branch + open PR (automation) or leave for human (workspace mode).
5. Persist evidence + result manifest.

Evidence layout must match `backlog/654-agentic-coding-cli-surface.md`.

## 7) GitHub integration (shared)

Automation PR creation uses GitHub App installation tokens (short-lived):

- Do not mount the GitHub App private key into workspaces.
- Use a platform-shared token-minting mechanism (usable by both Che and Coder) to obtain installation tokens.
- Use installation token for `git push` over HTTPS and PR creation via GitHub API.

## 8) Codex integration (shared)

Che task/workspace mounts:

- `Secret/codex-auth-rotating-N` (file `auth.json`) as the authentication source.
- `Secret/codex-account-status-N` (file `status.json`) to decide usability/selection.

Selection rule (minimum):

- If a slot is `usable=false` or missing, do not use it.
- If multiple slots are usable, pick the highest `score` (least depleted).

## 9) DevWorkspace skeleton (illustrative)

This is illustrative; exact fields depend on the provider image build + repo checkout conventions.

```yaml
apiVersion: workspace.devfile.io/v1alpha2
kind: DevWorkspace
metadata:
  name: <run-id-or-workspace-name>
  namespace: <che-namespace-or-automation-namespace>
spec:
  routingClass: che
  started: true
  template:
    projects:
      - name: repo
        git:
          remotes:
            origin: https://github.com/<org>/<repo>.git
          checkoutFrom:
            revision: <ref>
    components:
      - name: tooling
        container:
          image: ghcr.io/ameideio/<workspace-image>@sha256:<digest>
          mountSources: true
          env:
            - name: AMEIDE_AGENT_PROFILE
              value: "<code|gitops|sre>"
            - name: AMEIDE_RUN_ID
              value: "<run-id>"
            - name: AMEIDE_RUN_INTENT
              value: "<workspace|task>"
    commands:
      - id: agent-run
        exec:
          label: "Agent: Run"
          component: tooling
          workingDir: ${PROJECT_SOURCE}
          commandLine: "/usr/local/bin/ameide-agent-entrypoint"
      - id: agent-tail
        exec:
          label: "Agent: Tail logs"
          component: tooling
          workingDir: ${PROJECT_SOURCE}
          commandLine: "tail -f artifacts/agent-ci/${AMEIDE_RUN_ID}/run.log || true"
    events:
      postStart:
        - agent-run # only for task mode (automation intent) + idempotent entrypoint
```

## 10) Delivery plan (E2E increments, aligned)

### Increment 0 — Che baseline + SSO

- Che installed + Keycloak OIDC works; human can open VS Code web.

### Increment 1 — Che workspace image parity + CLI front doors

- Workspace image is digest-pinned and derived from the devcontainer contract.
- Running `ameide test` in Che produces evidence in the standard layout.

### Increment 2 — Che “task mode” supervised by Camunda

- Camunda triggers an ephemeral Che run with TTL/cleanup.
- Run produces evidence bundle and a deterministic outcome record.

### Increment 3 — Codex in Che (pinned + rotating auth + depletion-aware)

- Task mounts `codex-auth-rotating-N`, reads `codex-account-status-N`, uses pinned Codex CLI.

### Increment 4 — PR automation end-to-end

- Task pushes branch + opens PR with GitHub App installation token.

### Increment 5 — Provider parity checks (Che + Coder)

- Same run intent succeeds on both providers with identical evidence expectations and guardrails.

## 11) Open questions (to resolve for “both providers, both modes”)

1. **Default namespace for automation tasks:** dedicated automation namespaces (preferred) vs user namespaces.
2. **Profile selection source of truth:** `.ameide/agent-profile` + `AMEIDE_AGENT_PROFILE` precedence.
3. **Cross-provider UX for “open the environment”:** contract is evidence-first; provider URLs are optional convenience fields.
